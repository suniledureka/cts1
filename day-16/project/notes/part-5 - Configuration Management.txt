===== Configuration Management in Microservices ======

Challenge #4

--> Separation of Configurations/ properties
--> Inject Configs/ Properties
--> Maintain Configs/ Properties

Solutions:

1) Configuring Spring Boot with Properties and Profiles
2) Applying external configuration with Spring Boot
3) Implementing a Configuration Server with Spring Boot Cloud Config Server


---- How Configuration works in Spring Boot ---------
	application.properties or application.yml


---- Reading configurations using @Value annotation ---------
accounts microservices

in application.yml and a new property

build:
  version: "1.0"

in controller class AccountsController

@Value("${build.version}")
private String buildVersion;



@GetMapping("/build-info")
public ResponseEntity<String> getBuildInfo() {
  return ResponseEntity
                .status(HttpStatus.OK)
                .body(buildVersion);
}


run the app
http://localhost:8080/api/build-info


---- Reading configurations using Environment Interface ---------

why to go for environment variables - cant we use application.properties
- incase of some sensitive information like passwords - we don't want to define it in properties - use Environment variables - only server admins have access to env variables

in AccountsController
@Autowired
private Environment environment

@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
     return ResponseEntity
              .status(HttpStatus.OK)
              .body(environment.getProperty("JAVA_HOME"));
}



---- Reading configurations using @ConfigurationProperties annotation ---------

in application.yml

accounts:
  message: "Welcome to Bank accounts related APIs"
  contactDetails:
    name: "Sunil Joseph - Developer"
    email: "sunil@example.com"
  onCallSupport:
    - (40) 238-41700
    - (40) 238-41701


create a Record in dto package --- AccountsContactInfoDto.java  

@ConfigurationProperties(prefix = "accounts")
public record AccountsContactInfoDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) { }


in Controller class

@Autowired
private AccountsContactInfoDto accountsContactInfoDto;


    @GetMapping("/contact-info")
    public ResponseEntity<AccountsContactInfoDto> getContactInfo() {
        return ResponseEntity
                .status(HttpStatus.OK)
                .body(accountsContactInfoDto);
    }

on bootstrap class
@EnableConfigurationProperties(value = {AccountsContactInfoDto.class})




---- Using Spring Boot Profiles ---------

application-prod.properties
application-qa.properties

spring.profiles.active=dev

Practicals

application-prod.yml

spring:
  config:
    activate:
      on-profile: "prod"
build:
  version: "1.0"

accounts:
  message: "Welcome to Bank accounts related prod APIs "
  contactDetails:
    name: "Valerie - Product Owner"
    email: "valerie@example.com"
  onCallSupport:
    - (453) 392-4829
    - (236) 203-0384

application-qa.yml

spring:
  config:
    activate:
      on-profile: "qa"

build:
  version: "2.0"

accounts:
  message: "Welcome to Bank accounts related QA APIs "
  contactDetails:
    name: "Sanjay - QA Lead"
    email: "sanjay@example.com"
  onCallSupport:
    - (040) 265-3765
    - (040) 734-8371


in application.yml
spring:
 config:
   import:
    - "application-qa.yml"
    - "application-prod.yml"

 profiles:
   active:
    - "qa"



---- Externalizing configurations using commandline, JVM, & environment options ---------

in the above approach we need to make changes to application.yml everytime to specify the environment - need to regenerate the docker image


a) how to externalize configurations using commandline argument
cmd> java -jar target/accounts.jar --build.version="9.1"
     java -jar target/accounts.jar --build.version=9.1

	http://localhost:8080/api/build-info

b) how to externalize configurations using JVM System Properties

cmd>java -Dbuild.version="1.2" -jar accounts.jar

c) how to externalize configurations using environment variables  - 73
widely used as they are universally supportted
no lower case value only uppercase "build.version" to "BUILD_VERSION"

cmd>env:BUILD_VERSION="1.3";java -jar accounts.jar
	OR
cmd>set BUILD_VERSION=1.3      -- to declare an environment variable temporarly
cmd>java -jar accounts.jar


---- Activating the profile using commandline, JVM & environment options externally ---------

a) using command line
Run As --> Run Configurations
	--spring.profiles.active=prod

b) using JVM system variables
Run Configurations - VM Arguments
	-Dspring.profiles.active=prod
	-Dbuild.version=1.3

c) environment variables
Run Configurations -- Environment (tab)
SPRING_PROFILES_ACTIVE=prod;BUILD_VERSION=1.3


-------------- Assignment to make Spring Boot profile changes inside loans & cards microservices ----------------------

---- Drawbacks of externalized configurations using SpringBoot alone ----



====== Spring Cloud Config  ======

Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system.

we have seen how to manage configurations with spring boot alone. 

we maintain the configurations along with spring boot - it has got lot of issues and limitations.

we are going to see a better approach or the recommended approach we need to use - by using "spring cloud config" of spring ecosystem just maintain the configurations inside any cloud native system like microservices or any cloud applications.

In this approach we are going to have a centralized configuration server - which means we need to build a separate application that is going to act as a configuration server with the help of spring cloud config. 

using this centralized config server we can overcome all the limitations and drawbacks of the previous approach.

this approach will provide support for server and client for externalized configurations in a distributed system like microservices.

all our microservices should be registered as clients with this config server and this can act as a centralized config server.

https://spring.io   -- projects  -- Spring Cloud  -- Spring Cloud Config


What is Spring Cloud Config?

Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system.




--------- Building Config Server using Spring Cloud ---------------
Practicals:

New Spring Boot Starter Project  - configserver
Config Server for CTSBank microservices

Dependencies : Config Server , Actuator, 
config server dependency (spring-cloud-config-server) - Central management for configuration via Git, SVN, or HashiCorp Vault etc.

pom.xml

  https://spring.io/projects/spring-cloud

on bootstrap class  - @EnableConfigServer

application.yml

server:
  port: 8071

now our config server is available inside our microservices network. as of now there is no place for our config server to read the configurations; - we need to move all the required configurations of our microservices to a centralized location and we need to configure the centralized location inside our config server - so that our config server will start reading the configuration details  - there are multiple options available like classpath, filesystem, github repo, database, cloud like AWS S3 etc





---------------- Reading configurations from a GitHub Repository --------------

--> most recommended approach 
advantages --> we can properly secure the GitHub Repo - so that no one can access it
           --> it supports versioning, auditing
           --> in future we can check what property we have used last year (we can see the GitHub History) 	


=== PRACTICALS ====

-- create a new GitHubRepository with the name of "configurations" (or any other proper name)

https://github.com/suniledureka/configurations  ---  push a file with name of "welcome.properties" with the following content

		msg=Welcome to Cognizant

1) New Spring Starter Project: config_server
Dependencies: Config Server (spring-cloud-config-server)

Config Server Dependency (spring-cloud-config-server) --> Central management for configuration via Git, SVN, or HashiCorp Vault
	
on bootstrap class ---> @EnableConfigServer

-- application.properties ---
spring:
  application:
    name: config_server

  cloud:
    config:
      server:
        git:
          uri: https://github.com/suniledureka/configurations
server:
  port: 9093	


2) New Spring Starter Project: config_client
Dependencies: Actuator, Config Client (spring-cloud-starter-config)

Config Client Dependency --> Client that connects to a Spring Cloud Config Server to fetch the application's configuration


--- application.yml ---
spring:
  application:
    name: welcome    <---- important as it will fetch details from welcome.properties/ welcome.yml
  config:
    import: optional:configserver:http://localhost:9093
management:
  endpoints:
    web:
      exposure:
        include: refresh				

The optional: prefix in spring.config.import in Spring Boot indicates that the specified configuration location is not strictly required for the application to start. 


-- create a RestController with an endpoint of /welcome

package com.cognizant.boot.rest;

@RestController
@RefreshScope   
public class WelcomeRestController {

	@Value("${msg}")
	private String message;
	
	@GetMapping(path = "/welcome")
	public String showWelcomeMessage() {
		return message;
	}


@RefreshScope annotation in Spring Cloud allows for the dynamic refreshing of configuration properties within a Spring Boot application without requiring a full application restart


-- Run config_server, config_client

POSTMAN   GET   http://localhost:8080/welcome
make some changes to "msg" in welcome.properties of GitHub
POSTMAN   POST  http://localhost:8080/actuator/refresh

POSTMAN   GET   http://localhost:8080/welcome


================================================================


1) move all the properties to a GitHub repo
create a new repo ->cts-config
push all accounts, loans and cards yml files

2) application.yml of config server

spring.profiles.active=git

spring.cloud.config.server.git.uri="https://github.com/suniledureka/cts-config.git"
spring.cloud.config.server.git.default-label: main    	-- to specify the branch
spring.cloud.config.server.git.timeout: 5 		-- 5 seconds throw exception after
spring.cloud.config.server.git.clone-on-start: true	-- telling config server to clone the repo to local system in the startup itself; other wise cloning will happen only when the first request comes to config server

spring.cloud.config.server.git.force-pull: true		-- telling to override all the local changes in the local repository 


Run all microservices and test in postman  - check logs

http://localhost:8071/accounts/prod

http://localhost:8080/api/contact-info


https://docs.spring.io/spring-cloud-config/reference/   -- Git Backend -- Authentication (for private GitHub Repository)




================================= Extra ============================
------ Reading configurations from the classpath location of Config Server ------

application.yml

spring:
  application:
    name: "configserver"

src/main/resources/config
 place properties.yml, properties_prod.yml, properties_qa.yml from accounts microservices and rename to accounts.yml, accounts-prod.yml, accounts-qa.yml etc

 ---> in all the files we maintain only the "build" and "accounts" elements

same for loans and cards in configserver

-- add an additional property in application.yml
spring:
 profiles:
  active: native    -- telling to spring cloud config server that we want to activate a native profile of 			spring cloud 			config server (mainly for classpath)


spring.cloud.config.server.native.search-locations="classpath:/config"

Run as Spring boot application
in browser - http://localhost:8071/accounts/prod
	     http://localhost:8071/accounts/qa

to display json data in a proper manner in browser - JSONView
 


------ Updating accounts microservices to read properties from Config Server ------

task -> connect our accounts microservice to config server 
in accounts ms - delete _prod and _qa yml files

-- add a new dependency in pom.xml of accounts ms   ---> Config Client   
spring-cloud-starter-config - Client that connects to a Spring Cloud Config Server to fetch the application's configuration.


in application.yml
keep only 
 server.port

 spring.datasource
 spring.h2
 spring.jpa			delete - spring.config.import


add the following properties
spring.application.name = "accounts"     --- should match with accounts-prod, accounts-qa etc
spring.profiles.active="prod"

spring.config.import= "optional:configserver:http://localhost:8071/"

-- run accounts ms - this will go and connect to config server
-- check the logs

http://localhost:8080/api/build-info
http://localhost:8080/api/contact-info

------------------------------------
accounts - application.yml

server:
  port: 8080
spring:
  application:
    name: "accounts"
  profiles:
    active: "prod"    
  datasource:
    url: jdbc:h2:mem:testdb
    driverClassName: org.h2.Driver
    username: sa
    password: ''
  h2:
    console:
      enabled: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: true
  config:
   import: "optional:configserver:http://localhost:8071/"   

------------------------------------
configserver - application.yml

spring:
  application:
    name: "configserver"
  profiles:
    active: native
  cloud:
    config:
      server:
        native:
          search-locations: "classpath:/config" 
server:
  port: 8071    

-----------------------------------------------

case 2
provide the active profile externally as commandline argument 
Run Configurations  --spring.profiles.active=qa

-----------------------------------------------

Task ===> Update Loans & Cards Microservices to read the properties from ConfigServer




---------------- Reading configurations from a file system location --------------

advantage - the details can be placed in the server where the microservice is deployed


place all the files of src/main/resources/config to a folder location like C:\zettamine\config

in application.yml of configserver

spring.cloud.config.server.native.search-locations="file:///cts/config"


