Making Microservices Resilient / Resilience in Microservices
============================================================

Resilient = able to withstand or recover quickly from difficult conditions./ something capable of withstanding the tough times and bouncing back to a normal life. 

microservices are resilient in nature - so that they can withstand tough times like network problem or any performance issues - so these kind of challenges our microservices may face on day-to-day basis 

--------- Need of Resiliency inside Microservices -------------

Challenge # 7

1) How do we avoid cascading failures inside our microservices network?
    we all know that - inside a microservice network when my client application or my UI application is sending a request to the microservice network - many microservices will work together and they will send a combined response to the client application. In such scenario - how we are going to handle a scenario where one of the service is failing  or responding very slowly - how do we make sure that it is not having an effect on the other microservices
 accounts ---> loans & cards --- total response back to client
	--> loans or cards microservice fails - other microservices keep waiting
 we need to make sure that the entire chain of microservices does not fail if one of the participating microservice is failing or is responding slowly

2) How do we handle failures gracefully with fallbacks?
    if any of the microservice (accounts) is not working - at least we should be able to return back cards or loans data information to client instead of sending an exception saying that we are not able to send any kind of information - 
   return a default value, or a value from cache or call another service

3) How to make our services self healing capable?
  If one of the participating microservice inside a microservice network is responding very slowly due to some performance issue or due to some network issues - how we are going to make our services self healing capable. how to configure some timeouts , retries or give time for a failed microservice to recover itself 

Solution:

-> inside microservices there are many patterns to build resilient applications. 

In the java ecosystem we used to have a library called Hystrix (developed by Netflix team itself) previously. 
Hystrix entered maintenance mode in 2018, now we use a new library - Resilience4J ; it supports many resilient related patterns which we can use based on business requirements


Resilience4J --> is a lightweight fault tolerance library designed for functional programming. It offers the following patterns for increasing fault tolerance due to network problems or failure of any of the multiple services:

 --> Circuit Breaker -- used to stop making requests when a service invoked is failing
 --> Fallback -- alternative paths to failing requests
 --> Retry -- used to make retries when a service has temporarily failed
 --> Rate Limit -- limits the number of calls that a services receives in a time
 --> Bulkhead -- limits the number of outgoing concurrent requests to a service to avoid overloading

reference: https://resilience4j.readme.io/   ---- Core Modules --- View More

	   https://resilience4j.readme.io/docs/getting-started


--------- Typical use-case or scenario for the need of Resiliency inside Microservices -------------

resource usage (memory, threads) is more in accounts microservice as it is waiting for the response from cards microservice and same happens in Edge server




Practical::   in accounts ms  add a new endpoint GET  http://localhost:8080/api/contact-info

(a) in application.yml

accounts:
  message: "Welcome to Cognizant Bank accounts related APIs"
  contactDetails:
    name: "Sunil Joseph - Developer"
    email: "sunil@cognizant.com"
  onCallSupport:
    - (40) 238-41700
    - (40) 238-41701


(b) create a Record in dto package as AccountsContactInfoDto.java

@ConfigurationProperties(prefix = "accounts")
public record AccountsContactInfoDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) {

}

(c) in controller class -  CustomerController.java
    @Autowired
    private AccountsContactInfoDto accountsContactInfoDto;
    
    @GetMapping("/contact-info")
    public ResponseEntity<AccountsContactInfoDto> getContactInfo(){
    	return ResponseEntity.status(HttpStatus.OK)
			     .body(accountsContactInfoDto);
    }

(d) to enable support for @ConfigurationProperties annotated beans
on bootstrap class

@EnableConfigurationProperties(value = {AccountsContactInfoDto.class})


(e) Run eureka server, accounts, gateway server

(f) GET http://localhost:8072/ctsbank/accounts/api/contact-info



-------- Circuit Breaker Pattern -------------
short circuit

circuit breaker pattern will stop all the future requests coming to the cards microservice and will send the immediate failed response to the accounts microservice and from there to gateway

--------- Three states of Circuit Breaker Pattern -------------

how circuit breaker pattern is going to control the traffic coming towards a particular microservice. by default circuit breaker is not going to monitor all the microservices - we need to configure the circuit breaker pattern wherever we need 

whenever we activate the circuit breaker pattern to any microservice - it is going to control the flow towards the microservice by using 3 different states
 (a) CLOSED state
 (b) OPEN state
 (c) HALF_OPEN state



--------- Implement Circuit Breaker Pattern in Gateway & Implement Circuit Breaker Pattern with Feign Client -------------

task : implement circuit breaker pattern in Gateway server and inside accounts microservice

-- inside gatewayserver project

dependency: Resilience4j  - spring-cloud-starter-circuitbreaker-reactor-resilience4j
Spring Cloud Circuit breaker with Resilience4j as the underlying implementation

check in pom.xml and make sure the added dependency is spring-cloud-starter-circuitbreaker-reactor-resilience4j not spring-cloud-starter-circuitbreaker-resilience4j


-- inside bootstrap class
@Bean
public RouteLocator ctsBankRouteConfig(RouteLocatorBuilder routeLocatorBuilder) {
 return routeLocatorBuilder.routes()
 	.route(p -> p
   		    .path("/ctsbank/accounts/**")
		    .filters( f -> f.rewritePath("/ctsbank/accounts/(?<segment>.*)","/${segment}")
				.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
				.circuitBreaker(config -> config.setName("accountsCircuitBreaker")))

		   .uri("lb://ACCOUNTS"))


-- in application.yml of gatewayserver

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000


resilience4j.circuitbreaker.configs.default.slidingWindowSize= 10
resilience4j.circuitbreaker.configs.default.failureRateThreshold= 50
resilience4j.circuitbreaker.configs.default.waitDurationInOpenState: 10000
resilience4j.circuitbreaker.configs.default.permittedNumberOfCallsInHalfOpenState= 2


slidingWindowSize: 10  --- using this property we are communicating to the circuit breaker pattern on how many requests it has to initially monitor before it tries to change the status from closed to open state ; or in other words with this property we are telling to circuit breaker pattern - please at least monitor 10 requests coming towards our accounts microservice - after monitoring 10 requests take the decision whether to continue with the closed state or move to the open status

permittedNumberOfCallsInHalfOpenState: 2 --- once the circuit breaker pattern moved into open state - it will never be in open status for ever - periodically it is going to move to the half-open state and it is going to allow certain amount of traffic to the accounts microservice and since circuit breaker pattern cannot decide how many requests it has to pass - we need to provide such information to circuit breaker pattern using this property;  here we mentioned the value 2 - this means I want my circuit breaker pattern to allow 2 requests in the half-open status - based on how these 2 requests are processed - it can decide whether to go back to the open state or move to the close state 
 
failureRateThreshold: 50 ---- atleast 50% of my requests are failed then my circuit breaker pattern can move to the open state from the closed state 

waitDurationInOpenState: 10000 (10000ms) --- our circuit breaker pattern is going to wait for 10s whenever it will try to move to half-open state and allow the partial traffic.



resilience4j:
  circuitbreaker:
    configs:
      default:
        sliding-window-size: 10
        failure-rate-threshold: 50
        wait-duration-in-open-state: 8000
        permitted-number-of-calls-in-half-open-state: 3




resilience4j.circuitbreaker.configs.default ----> settings are applicable for all kind of circuit breakers that we are  going to create inside our microservice
            incase if we want to go with different properties for different circuit breakers , then we need to use the circuit breaker name as we defined above as "accountsCircuitBreaker"


resilience4j.circuitbreaker.configs.accountsCircuitBreaker:


Run eureka server,  - Debug accounts (only),  Run Gateway

http//localhost:8761/    ----- eureka dashboard

--actuator of gateway server
http//localhost:8072/actuator    -- check for circuitbreakers
http//localhost:8072/actuator/circuitbreakers   --- empty now

--> to understand the events that are happening behind the scenes under the circuitbreaker
http://localhost:8072/actuator/circuitbreakerevents --- empty now


test accounts microservice with gateway server all the circuit breaker related information gets populated inside actuator/circuitbreaker

POSTMAN  --- GET http://localhost:8072/ctsbank/accounts/api/contact-info

http//localhost:8072/actuator/circuitbreakers    --- content
http://localhost:8072/actuator/circuitbreakerevents --- content


http//localhost:8072/actuator/circuitbreakerevents?name=accountsCircuitBreaker  -- only one event
http://localhost:8072/actuator/circuitbreakerevents/accountsCircuitBreaker

POSTMAN  --- GET http://localhost:8072/ctsbank/accounts/api/contact-info
POSTMAN  --- GET http://localhost:8072/ctsbank/accounts/api/contact-info

http//localhost:8072/actuator/circuitbreakerevents?name=accountsCircuitBreaker   -- 2 events
from this we can understand that the circuit breaker is monitoring our microservice continuously

http//localhost:8072/actuator/circuitbreakers      bufferedCalls: 2, state: CLOSED



----> to check the real performance or demo of circuitbreaker pattern ---
inside AccountsController  (to mimic the slow response -- set a breakpoint on the following method)

@GetMapping
public ResponseEntity<AccountContactInfoDto> getContactInfo(){
  return ResponseEntity
		.status(HttpStatus.OK)
		.body(accountsContactInfo);
}

POSTMAN  --- GET http://localhost:8072/ctsbank/accounts/api/contact-info
  ---> breakpoint stopped the execution

http//localhost:8072/actuator/circuitbreakerevents?name=accountsCircuitBreaker    type:ERROR

http//localhost:8072/actuator/circuitbreakers		state still in CLOSED state - 50% of the calls never failed

POSTMAN  --- GET http://localhost:8072/ctsbank/accounts/api/contact-info  -- 4 times - check the error response


http//localhost:8072/actuator/circuitbreakerevents?name=accountsCircuitBreaker    type:ERROR, FAILURE_RATE_EXCEEDED, STATE_TRANSITION, NOT_PERMITTED

http//localhost:8072/actuator/circuitbreakers		


POSTMAN  --- GET http://localhost:8072/ctsobank/accounts/api/contact-info 

now in HALF_OPEN state and after 2 requests it will be back to OPEN_STATE

release the breakpoint


resilience4j:
  timelimiter:
    configs:
      default:
        timeout-duration: 10s 


---------------------------------------------------->

we have implemented circuit breaker pattern inside Gateway server - but does not have any fall back mechanism - since we don't have any fallback mechanism inside the response we are throwing some runtime exception details like service unavailable or gateway timeout exception etc. 

In real business applications throwing runtime exceptions to the client application or UI application is not a valid approach - we need to have some fallback mechanism and inside this fallback mechanism we can write some logic where we can send some message to the client applications which is going to make sense for them. 

--- To create a fallback mechanism for circuit breaker pattern 

inside gateway server application - create a new controller class

package com.cognizant.gatewayserver.controller;

@RestController
public class FallbackController {
    @RequestMapping("/contactSupport")
    public Mono<String> contactSupport() {
        return Mono.just("An error occurred. Please try after some time or contact support team!!!");
    }
}


inside bootstrap class
@Bean
public RouteLocator ctsBankRouteConfig(RouteLocatorBuilder routeLocatorBuilder) 
{
 return routeLocatorBuilder.routes()
    .route(p -> p
	 	 .path("/ctsbank/accounts/**")
		 .filters( f -> f.rewritePath("/ctsbank/accounts/(?<segment>.*)","/${segment}")
		.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
		.circuitBreaker(config -> config.setName("accountsCircuitBreaker")
					.setFallbackUri("forward:/contactSupport"))) //accounts/contactSupports
	.uri("lb://ACCOUNTS"))


POSTMAN GET  http://localhost:8072/ctsbank/accounts/api/contact-info    <--- happy response

http://localhost:8072/actuator/circuitBreakers		state: CLOSED

http//localhost:8072/actuator/circuitbreakerevents?name=accountsCircuitBreaker

work with breakpoint in accounts microservice for mimicking slow response

POSTMAN GET  http://localhost:8072/ctsbank/accounts/api/contact-info

release the breakpoint



--------- Implementing Circuit Breaker pattern with Feign Client  -------------

implementing circuit breaker pattern inside accounts microservice

inside accounts microservice - there is a REST API with name "/fetchCustomerDetails"  in CustomerController- as part of this REST API our accounts microservice is going to invoke cards microservice and loans microservice 

- what if, one of the dependent microservice like loans or cards microservice is responding very slowly or if they are completely down or there are some network issues. In such scenarios it is going to have some ripple effect of our accounts microservice and from account microservice to gateway server. 

we can implement circuit breaker pattern inside accounts microservice

Refer: https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#spring-cloud-feign-circuitbreaker

-- in accounts microservice--

dependency - Resiliece4j (spring-cloud-starter-circuitbreaker-resilience4j -as we have not developed accounts microservice based on spring reactor)

-- application.yml of accounts microservice

spring:
  cloud:
    openfeign:
      circuitbreaker:
        enabled: true	--> to activate circuit breaker for all the openfeign clients inside the accounts microservice

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000


spring.io > spring cloud > spring cloud openfeign > Learn > documentation > Feign SpringCloud Circuit Breaker Fallbacks

what should happen when loans/ cards microservice is down?

package com.cognizant.accounts.service.client;
@Component
public class LoansFallback implements LoansFeignClient{

    @Override
    public ResponseEntity<LoansDto> fetchLoanDetails(String correlationId, String mobileNumber) {
        return null; //to overcome from firing exception; atleast client gets accounts & cards details
    }
}


@Component
public class CardsFallback implements CardsFeignClient{

    @Override
    public ResponseEntity<CardsDto> fetchCardDetails(String correlationId, String mobileNumber) {
        return null;  
    }
}


@FeignClient(name="loans", fallback = LoansFallback.class)
public interface LoansFeignClient {
  @GetMapping(value = "/api/fetch", consumes = "application/json")
  public ResponseEntity<LoansDto> fetchLoanDetails(@RequestParam String mobileNumber);
}

@FeignClient(name="cards", fallback = CardsFallback.class)
public interface CardsFeignClient {
	@GetMapping(value = "/api/fetch", consumes = "application/json")
	public ResponseEntity<CardsDto> fetchCardDetails(@RequestParam String mobileNumber);
}

--- CustomerServiceImpl class

ResponseEntity<LoansDto> loansDtoResponseEntity = loansFeignClient.fetchLoanDetails(mobileNumber);
        if(loansDtoResponseEntity != null) {
            customerDetailsDto.setLoansDto(loansDtoResponseEntity.getBody());
        }

ResponseEntity<CardsDto> cardsDtoResponseEntity = cardsFeignClient.fetchCardDetails(mobileNumber);
        if(cardsDtoResponseEntity != null) {
            customerDetailsDto.setCardsDto(cardsDtoResponseEntity.getBody());
        }

--- testing----

start all applications -eureka, accounts, loans, cards, gateway

accounts microservice actuator
http://localhost:8080/actuator
http://localhost:8080/actuator/circuitbreakers     --- no data

POSTMAN POST -- create data accounts, cards, loans
POSTMAN GET --- /fetchCustomerDetails

http://localhost:8080/actuator/circuitbreakers

http://localhost:8080/actuator/circuitbreakerEvents


stop loans microservice

POSTMAN GET --- fetchCustomerDetails  loansDto: null because of fallback mechanism
		try multiple times

http://localhost:8080/actuator/circuitbreakers    -- loans state: OPEN

http://localhost:8080/actuator/circuitbreakerEvents

stop cards microservices

POSTMAN GET --- fetchCustomerDetails  loansDto & cards: null because of fallback mechanism
		try multiple times

http://localhost:8080/actuator/circuitbreakers 
http://localhost:8080/actuator/circuitbreakerEvents

start loans & cards microservice



--------- Http Timeout configurations -------------

we are going to see one of the most common scenario that we may face inside our real project and how to handle the same with the help of Spring Cloud Gateway

task : accessing the /contact-info API present inside LoansController

GET  http://localhost:8072/ctsbank/loans/contact-info

some time the response may take more than 30 seconds or more - we never know what is happening on the server side , may be the microservice is performing very slow, in such scenarios we may not get the immediate response. 

-- keep a break point on /contact-info of loans microservice

POSTMAN GET  http://localhost:8072/ctsbank/loans/contact-info    --- keep waiting for the response (a thread is waiting in the gateway server for getting the response) - unnecessarly we are making the threads , memory and other server resources to wait for the responses to come and we dont know when the response is going to come.  to overcome these challenges we should define some timeout configurations - so that we can configure to wait for a maximum period of time , beyond the configured time we are not going to wait for the response.

release the break point and check in postman

try on accounts microservice's /contact-info and we can see the fallback works on the breakpoint (inside GatewayServer application inside route's circuitBreaker configuration have got the timeout  

we need to configure timeout configuration

spring.io > spring cloud > spring cloud openfeign > Learn > documentation >Http timeout configuration

in application.yml of gateway server
spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000
	response-timeout: 2s

connect-timeout:  -- is the time that our gateway server is going to take to get a connection thread from the other microservice.

response-timeout: -- maximum time out gateway server is going to wait to receive the response from the respective microservice like loans microservice

debug the application - breakpoint on /contact-info
  
POSTMAN GET  http://localhost:8072/ctsbank/loans/contact-info   -- error message in postman

we did global configuration it will affect all the microservices in the network; but we did a specific configuration for accounts microservice

official documentation -- Per-route timeouts  for specific configurations


--------- Working with Retry Pattern -------------

Retry Pattern is a Resilience pattern
Idempotent - operations which will not result in any side effects regardless of how many times we invoke them, for ex: /fetch API operation



--------- Implementing Retry Pattern in Gateway -------------


implementing Retry pattern in Cloud Gateway
inside bootstrap class of gatewayserver - we have implemented circuit breaker pattern for accounts microservices

retry pattern for loans microservices

.route(p -> p
	    .path("/ctsbank/loans/**")
	.filters( f -> f.rewritePath("/ctsbank/loans/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.retry(retryConfig -> retryConfig.setRetries(3)
			.setMethods(HttpMethod.GET) 	//Idempotent methods		
			.setBackoff(Duration.ofMillis(100), Duration.ofMillis(1000), 2, true)))
  	.uri("lb://LOANS"))

firstBackOff - spring cloud gateway will wait for 100ms whenever it is trying to initiate the very first retry operation 

second parameter - maxBackOff -- think that we configured the number of retries as 10 - max time to wait between 2 retry operations

factor - what factor spring cloud gateway to apply based on the previous backoff value

basedOnPreviousValue - true -- to tell the spring cloud gateway whether to apply the factor value of the previous backoff number or the inital backoff number

The wait time between a request and its subsequent retry is called the backoff.


inside LoansController /contact-info  applying logger - to identify how many times my microservice api is invoked

    @GetMapping("/contact-info")
    public ResponseEntity<LoansContactInfoDto> getContactInfo() {
        logger.debug("Invoked Loans contact-info API");
        return ResponseEntity
                .status(HttpStatus.OK)
                .body(loansContactInfoDto);
    }

breakpoint on logger
debug all applications

POSTMAN GET  http://localhost:8072/loans/api/contact-info	1 + 3 retry times it requested so the Timeout shows as 8.x seconds in postman

release the breakpoint -- check in logs -- we could see logger message 4 times

change in code 

   @GetMapping("/contact-info")
    public ResponseEntity<LoansContactInfoDto> getContactInfo() {
        logger.debug("Invoked Loans contact-info API");
        throw new RuntimeException();
    }




--------- Implementing Retry Pattern in Accounts -------------

implementing Retry pattern in individual microservices

using /build-info API
inside AccountsController

    @Retry(name = "getBuildInfo",fallbackMethod = "getBuildInfoFallback")
    @GetMapping("/build-info")
    public ResponseEntity<String> getBuildInfo() {
        logger.debug("getBuildInfo() method Invoked");
        return ResponseEntity
                    .status(HttpStatus.OK)
                    .body(buildVersion);
    }

//fallback method signature should match with the exactly the original method - here the original method is getBuildInfo() 
//second rule that we need to follow is - fallback method should accept a method input parameter of type Throwable
 
    public ResponseEntity<String> getBuildInfoFallback(Throwable throwable) {
        logger.debug("getBuildInfoFallback() method Invoked");
	throw new NullPointerException();
        //return ResponseEntity
                .status(HttpStatus.OK)
                .body("0.9");   //returing a static value
    }

the above method will gets executed after multiple retry attempts

resilience4j/readme.io/docs/getting-started-3   --- Configuration


in application.yml of Accounts Microservice

resilience4j.retry:
  configs:
    default:
      max-attempts: 3
      waitDuration: 100
      enableExponentialBackoff: true
      exponentialBackoffMultiplier: 2

debug app

GET   http://localhost:8072/ctsbank/accounts/api/build-info   --- check in logs- here 3 times only shows as the first one also considered as a retry


for circuit breaker
      waitDuration: 500    -- fallback of circuit breaker comes into picture


to change the default configuration of circuit breaker - provide a inside GatewayServer bootstrap class - create a new bean

@Bean
public Customizer<ReactiveResilience4JCircuitBreakerFactory> defaultCustomizer() {
  return factory -> factory.configureDefault(id -> new Resilience4JConfigBuilder(id)
				.circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
				.timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(4)).build()).build());
}

debug the applications

GET   http://localhost:8072/ctsbank/accounts/api/build-info 




what if there is a business requirement saying that please don't retry whenever there is  a NullPointerException - because if there is a NullPointerException for the given input data regardless of how many times you retry - you will always get a NullPointerException - in such scenarios we dont want our Retry to happen - how to achieve this

application.yml of accounts microservice

resilience4j.retry:
  configs:
    default:
      maxRetryAttempts: 3
      waitDuration: 100
      enableExponentialBackoff: true
      exponentialBackoffMultiplier: 2
      ignoreExceptions:
        - java.lang.NullPointerException


debug the applications
/build-info   -- in postman  -- check in logs -- no retry attempts

to retry for a specific type of exceptions
resilience4j.retry:
  configs:
    default:
      maxRetryAttempts: 3
      waitDuration: 100
      enableExponentialBackoff: true
      exponentialBackoffMultiplier: 2
      ignoreExceptions:
        - java.lang.NullPointerException
      retryExceptions:
        - java.util.concurrent.TimeoutException

in Accounts Controller -- inside /build-info -- change NullPointerException to
 throw new TimeOutException();

POSTMAN   /build-info   -- check in logs of Accounts

120


--------- Rate Limitter Pattern -------------
baloon pop-up game   -- 3 or 5 chances   limited resources based on payment


response code 429


--------- Redis Rate Limitter in Gateway Server -------------

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory

123



--------- Implementing RateLimitter pattern in Gateway Server -------------

pom.xml - dependency - Spring Data Reactive Redis (spring-boot-starter-data-redis-reactive)

bootstrap application of gateway server

@Bean
public RedisRateLimiter redisRateLimiter() {
 return new RedisRateLimiter(1, 1, 1); //we are going to add 1 token in each second and burst capacity also going to be 1 and the cost of each request also going to be 1 - meaning - for each second my end user can only make one request 
}

@Bean
KeyResolver userKeyResolver() {
 return exchange -> Mono.justOrEmpty(exchange.getRequest().getHeaders().getFirst("user"))
		.defaultIfEmpty("anonymous");
}


implementing rateLimitter for cards inside gateway server

 .route(p -> p
 	.path("/ctsbank/cards/**")
	.filters( f -> f.rewritePath("/ctsbank/cards/(?<segment>.*)","/${segment}")
		.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
		.requestRateLimiter(config -> config.setRateLimiter(redisRateLimiter())
						.setKeyResolver(userKeyResolver())))
	.uri("lb://CARDS")).build();


-- next step
we need to start the Redis Database or Redis container -so that it can maintain creating the buckets with the user names ("user") and to maintain all the configurations like "new RedisRateLimiter(1,1,1,)"

we need to start the Redis container with the help of docker
-- Docker Desktop should be running

cmd> docker run -p 6379:6379 --name zettaredis -d redis

provide the connection details of redis container inside the application.yml of gateway server

spring:
  data:
    redis:
      connect-timeout: 2s
      host: localhost
      port: 6379
      timeout: 1s

run configserver, eureka, cards, gateway server -- no need to have accounts and cards - we implemented RateLimitter only for cards microservice

we need to fire muiltiple requests in a second

Download and install Apache Bench  https://httpd.apache.org  
https://www.apachelounge.com/download/

Google -- How to use Apache Bench for Load Testing 	- ubiq

cmd>ab -n 10 -c 2 -v 3 http://localhost:8072/ctsbank/cards/api/contact-info

-n ---> 10 requests
-c ---> concurrent as 2 , send 2 concurrent requests every time
-v ---> verbose to see the detailed report in the output



 

--------- Implementing RateLimitter pattern in accounts -------------

inside AccountsController     
/java-version API   
getJavaVersion() method to be invoked based on the rateLimitation that we have defined in application.yml
for that
   
    @RateLimiter(name= "getJavaVersion")
    @GetMapping("/java-version")
    public ResponseEntity<String> getJavaVersion() {
        return ResponseEntity
                .status(HttpStatus.OK)
                .body(environment.getProperty("JAVA_HOME"));
    }

we need to define the rate-limiter property in application.yml file

resilience4j.ratelimiter:
  configs:
    default:
      timeoutDuration: 1000
      limitRefreshPeriod: 5000
      limitForPeriod: 1


limitRefreshPeriod: 5000 ---> for every 5 seconds , we want to renew the quota , we set the quota for each refresh period as 1 -- limitForPeriod: 1	----> for every 5 seconds only 1 request is allowed

timeoutDuration: 1000 ---> what is the maximum time that a particular thread can wait for the new refresh period to arrive with the new quota -- based on the configuration our thread is waiting for a maximum of 1s; within 1sec my RateLimitter is not allowing the request then simply it is not going to wait further and return back with the error  


Run the applications  -- no need to have redis container

POSTMAN GET  http://localhost:8072/ctsbank/accounts/api/java-version  --- send the multiple request and we should be seeing the error saying that INTERNAL_SERVER_ERROR (error is fired because of RateLimitter)

in browser - http://localhost:8072/ctsbank/accounts/api/java-version     refresh


-- define the fallback mechanism

    @RateLimiter(name= "getJavaVersion", fallbackMethod = "getJavaVersionFallback")
    @GetMapping("/java-version")
    public ResponseEntity<String> getJavaVersion() {
        return ResponseEntity
                .status(HttpStatus.OK)
                .body(environment.getProperty("JAVA_HOME"));
    }


    public ResponseEntity<String> getJavaVersionFallback(Throwable throwable) {
        return ResponseEntity
                .status(HttpStatus.OK)
                .body("Java 17");
    }

Run the application - accounts, gateway

in browser - http://localhost:8072/ctsbank/accounts/api/java-version     refresh multiple times


--------- Bulk Head Pattern -------------

bulkhead -> partitions or compartments in a boat or ship
Titanic movie 

Refer: resilience4j.readme.io
https://resilience4j.readme.io/docs/getting-started-3      Annotations

super complicated process -- we may require some performance tools  like Load Runner, JMeter where we can see the Thread usage 


--------- Aspect order of Resiliency Patterns -------------

we have come across various resilience patterns in resilience4j library
we implemented the patterns individually
but in some cases like in a complex business logic where we may end up combining various resilience patterns; in such scenario we may have a question like what is the order that our resilience library is going to follow if we have multiple patterns defined for a single API or a single method or for a single service

https://resilience4j.readme.io/docs/getting-started-3     --- Aspect Order


Retry ( CircuitBreaker ( RateLimiter ( TimeLimiter ( Bulkhead ( Function ) ) ) ) )
so Retry is applied at the end (if needed).


