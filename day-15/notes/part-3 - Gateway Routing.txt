Gateway, Routing & Cross cutting concerns in Microservices
==========================================================

What are the challenges that we may face while we are trying to accept the external traffic into our microservices network?

We should have a single entry point into our microservice network; we should not allow different external clients talking with our microservices directly - instead we should have a single entry point into our microservices by using the products like API Gateway.

What are the challenges that we may face while we are trying to accept the external communication into our microservice?

Challenge # 

1) How do we maintain a single entry point into microservices network?
    here the question is - what is the problem if we don't maintain a single entry point; 
what if- I allow all the external clients to communicate directly with my microservices; there will be multiple drawbacks or challenges not maintaining a single entry point to our microservice network
  if we are not having a single entry point - then the external clients should maintain a track of all the microservices inside our microservice network, their endpoint URLs , port numbers, etc
 
    how do we build a single gatekeeper for all the inbound traffic to our microservices. This way the client does not need to keep track of the different services involved in a transaction, simplifying the client's logic

2) How do we handle cross cutting concerns
     logging, auditing, tracing & security

3) How do we route based on custom requirements?
     how to provide dynamic routing capabilities which allows to define routing rules based on various criteria such as HTTP headers (version v1, v2), request parameters etc inside microservices network

Solution:
these challenges in microservices can be solved using - Edge Server / API Gateway / Gateway - this server will be sitting on the edge of the microservice network and monitoring all the incoming and outgoing requests 


----- Why we need a Edge Server or API Gateway inside microservices ------------

cross cutting concerns  -- non functional requirements

inside API Gateway -  we can perform many functionalities
-> Request Validation
-> Include & Exclude List - to perform some checks related to black listing or white listing of the IP address 
-> Authentication & Authorization
-> Rate Limit - we can limit the quantity of requests or the amount of requests coming from a particular client 
-> Dynamic Routing
-> Service Discovery
-> Modify Request & Response
-> Protocol Conversion

we can also handle negative scenarios like
-> implementing Exception Handling
-> implementing Circuit breaker to make our microservices fault-tolerant and resilient in nature

API gateway is also capable of sending all the Logging & monitoring related information - with tools like Grafana - using this we look for all the logs and errors  or monitoring related information using beautiful dashboards

If we needed- we can also integrate API Gateway with Redis-cache - which means we can write some business logic by leveraging the cache that we can store inside this redis component

eureka sever is for service discovery and registration - which is entirely a different pattern. eureka server is not capable of performing all the non-functional requirements or implementing cross-cutting concerns

---------- Spring Cloud Gateway --------------


Spring Reactor & Spring WebFlux ---> Spring Reactive Programming

spring.io > Projects > Spring Cloud > Spring Cloud Gateway


---------- Spring Cloud Gateway Internal Architecture  --------------


spring.io > Projects > Spring Cloud > Spring Cloud Gateway > Learn



Spring Cloud Gateway have 3 important parts

1. Route - contains the URL to which request is to be forwarded to  
2. Predicate
3. Filter

In Spring Cloud Gateway, predicates are a core component of route definition, acting as conditions that determine whether an incoming HTTP request matches a particular route.

Filters in Spring Cloud Gateway are a fundamental component of its routing and request/response manipulation capabilities. They allow for the modification of HTTP requests before they are forwarded to a downstream service (pre-filters) and the modification of HTTP responses before they are sent back to the client (post-filters).



---------- Building Edge Server using Spring Cloud Gateway --------------

Create a New Spring Starter Project - gatewayserver
Edge Server for CTS Bank microservices
com.cognizant.gatewayserver

Dependencies: Reactive Gateway, Eureka Discovery Client (to connect to the eureka server and to fetch the service registry details of all the other microservices) , 
Spring Boot Actuator, Spring Boot DevTools

-- application.yml ----  (from accounts ms and make corrections)

spring.application.name: "gatewayserver"
server.port: 8072

eureka.instance.preferIpAddress: true
eureka.client.registerWithEureka: true
eureka.client.fetchRegistry: true
eureka.client.serviceUrl.defaultZone: http://localhost:8761/eureka/

spring.cloud.gateway.discovery.locator.enabled: true   ---> we are telling to gateway server to connect with the discovery server (eureka) and locate all the details about the microservices - once it locates all the information about the individual microservices - we want the gateway server to use the same to forward the traffic from external client to the individual microservice 

management.endpoints.web.exposure.include: "*"
management.endpoint.gateway.enabled: true
management.info.env.enabled: true

info.app.name: "gatewayserver"
info.app.description: "CTS Bank Gateway Server Application"
info.app.version: "1.0.0" 



----> Edge Server with default routing configs

=====>  run eureka server, all microservices and then only gateway server

http://localhost:8761/ ---> eureka server dashboard

http://localhost:8072/actuator

http://localhost:8072/actuator/gateway

http://localhost:8072/actuator/gateway/routes

postman
POST   http://localhost:8072/ACCOUNTS/api/create

ACCOUNTS ---> name of ms in eureka server
api/create ---> actual path

GET http://localhost:8072/ACCOUNTS/api/fetch?mobileNumber= xxxxx

same way access loans and cards

http://localhost:8072/LOANS/api/create?mobileNumber=9848586878


---- make changes in application.properties/application.yml inside Gateway server to accept service names with lower case ----

	spring.cloud.gateway.discovery.locator.lower-case-service-id: true


POST   http://localhost:8072/accounts/api/create





======= PART 2 ==============

------ Implementing Custom Routing using Spring Cloud Gateway ------

custom requirement --> suppose we want to make the clients to send a request to 
  http://localhost:8072/ctsbank/accounts/api/create   
  http://localhost:8072/ctsbank/loans/api/create?mobileNumber=9848586878 
  http://localhost:8072/ctsbank/cards/api/create?mobileNumber=9848586878 

--- like dynamic routing --- define our-own routing configurations -- not the default routing configurations


in bootstrap class

	@Bean
	public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) {
	 return routeLocatorBuilder.routes()
				.route(path_route -> path_route
					     .path("/ctsbank/accounts/**")
					     .filters(f -> f.rewritePath("/ctsbank/accounts/(?<segment>.*)","/${segment}"))
					.uri("lb://ACCOUNTS")) 

				.route(p -> p
					     .path("/ctsbank/loans/**")
					     .filters( f -> f.rewritePath("/ctsbank/loans/(?<segment>.*)","/${segment}"))
					.uri("lb://LOANS")) 

				.route(p -> p
					     .path("/ctsbank/cards/**")
					     .filters( f -> f.rewritePath("/ctsbank/cards/(?<segment>.*)","/${segment}"))
					.uri("lb://CARDS")) 
		.build();			
	}	
}



run the application 

http://localhost:8072/ctsbank/accounts/api/create   

---> check  http://localhost:8072/actuator/gateway/routes

-- we can see the default configurations also - to disable the default behaviour
spring.cloud.gateway.discovery.locator.enabled: false

---> check  http://localhost:8072/actuator/gateway/routes


============== PART - 3 =================


--- addResponeHeader filter -----------------

refer in official documentation
spring.io > Projects > Spring Cloud > Spring Cloud Gateway > Learn
 --> Fluent Java Routes API
 --> Route Predicate Factories  - The path Route Predicate Factory

 --> GatewayFilter Factories  - The AddResponseHeader GatewayFilter Factory

			.route(p -> p
			    .path("/ctsbank/accounts/**")
			    .filters( f -> f.rewritePath("/ctsbank/accounts/(?<segment>.*)","/${segment}")
					.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
				.uri("lb://ACCOUNTS")) 


add the responseHeader filter for the rest route also

run the application
http://localhost:8072/ctsbank/accounts/api/create   
  check the Response Headers in POSTMAN

==================================================================================================

Route configurations using application.yml

Approach -2 in application.yml

spring:
  application:
    name: GATEWAY-SERVICE
  cloud:
    gateway:
      routes:
      - id: order-service
        uri: lb://ORDER-SERVICE      #lb â€“ load balancer
        predicates:			#URL Patterns
          - path=/order/**
      - id: payment-service
        uri: lb://PAYMENT-SERVICE
        predicates:
          - path=/payment/**    



Route configurations using application.properties

API Gate Way routing Configuration
server.port=9090
eureka.client.serviceUrl.defaultZone = http://localhost:8083/eureka
spring.application.name=ApiGateway
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true

spring.cloud.gateway.routes[0].id=service1
spring.cloud.gateway.routes[0].uri=lb://MICROSERVICE1
spring.cloud.gateway.routes[0].predicates[0]=Path=/service1/**


===========================================  END =================================================










----------- Implementing Cross cutting concerns Tracing & Logging using Gateway ------------

Business Scenario / Requirement : as soon as our Gateway server receives an external traffic/ request it has to generate an ID (a randomly generated value like correlation ID or Trace ID) and the same ID to be forwarded to all the further microservices that my request is going to travel - gateway to accounts, accounts to loans and cards, need to do some logging and also send the ID back to client with response header


Practicals:

-> create custom filters

1) RequestTraceFilter ---> responsible to generate an ID (trace ID/ Correlation ID) when ever a new request comes to our Gateway server from the external client application

2) ResponseTraceFilter ---> responsible to add the ID (trace ID/ Correlation ID) into the response so that the client also will be aware of the trace ID

3) FilterUtility ---> responsible to define all the common logics which is needed for Request and Response Trace filters 

package com.cognizant.gatewayserver.filters;

@Component
public class FilterUtility {

    public static final String CORRELATION_ID = "ctsbank-correlation-id";

    public String geHttpHeaders requestHeaders) {
        if (requestHeaders.get(CORRELATION_ID) != null) {
            List<String> requestHeaderList = requestHeaders.get(CORRELATION_ID);
            return requestHeaderList.stream().findFirst().get();
        } else {tCorrelationId(
            return null;
        }
    }

    public ServerWebExchange setRequestHeader(ServerWebExchange exchange, String name, String value) {
        return exchange.mutate().request(exchange.getRequest().mutate().header(name, value).build()).build();
    }

    public ServerWebExchange setCorrelationId(ServerWebExchange exchange, String correlationId) {
        return this.setRequestHeader(exchange, CORRELATION_ID, correlationId);
    }
}



package com.cts.gatewayserver.filters;
@Order(1)
@Component
public class RequestTraceFilter implements GlobalFilter {

    private static final Logger logger = LoggerFactory.getLogger(RequestTraceFilter.class);

    @Autowired
    FilterUtility filterUtility;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        HttpHeaders requestHeaders = exchange.getRequest().getHeaders();
        if (isCorrelationIdPresent(requestHeaders)) {
            logger.debug("ctsBank-correlation-id found in RequestTraceFilter : {}",
                    filterUtility.getCorrelationId(requestHeaders));
        } else {
            String correlationID = generateCorrelationId();
            exchange = filterUtility.setCorrelationId(exchange, correlationID);
            logger.debug("ctsBank-correlation-id generated in RequestTraceFilter : {}", correlationID);
        }
        return chain.filter(exchange);
    }

    private boolean isCorrelationIdPresent(HttpHeaders requestHeaders) {
        if (filterUtility.getCorrelationId(requestHeaders) != null) {
            return true;
        } else {
            return false;
        }
    }

    private String generateCorrelationId() {
        return java.util.UUID.randomUUID().toString();
    }

}




package com.cts.gatewayserver.filters;
@Configuration
public class ResponseTraceFilter {

    private static final Logger logger = LoggerFactory.getLogger(ResponseTraceFilter.class);

    @Autowired
    FilterUtility filterUtility;

    @Bean
    public GlobalFilter postGlobalFilter() {
        return (exchange, chain) -> {
            return chain.filter(exchange).then(Mono.fromRunnable(() -> {
                HttpHeaders requestHeaders = exchange.getRequest().getHeaders();
                String correlationId = filterUtility.getCorrelationId(requestHeaders);
                logger.debug("Updated the correlation id to the outbound headers: {}", correlationId);
                exchange.getResponse().getHeaders().add(filterUtility.CORRELATION_ID, correlationId);
            }));
        };
    }
}


@Order(1)  ---> order of filter execution

to activate the debug logger 

logging:
  level:
    com:
      cognizant:    
        gatewayserver: DEBUG



in accounts ms 
-> got controllers - AccountsController & CustomerController

inside CustomerController

private static final Logger logger = LoggerFactory.getLogger(CustomerController.class);


    @GetMapping("/fetchCustomerDetails")
    public ResponseEntity<CustomerDetailsDto> fetchCustomerDetails(@RequestHeader("ctsbank-correlation-id") String correlationId,  @RequestParam @Pattern(regexp="(^$|[0-9]{10})", message = "Mobile number must be 10 digits") String mobileNumber) {
        logger.debug("ctsBank-correlation-id found: {} ", correlationId);
        CustomerDetailsDto customerDetailsDto = iCustomersService.fetchCustomerDetails(mobileNumber, correlationId);
        return ResponseEntity.status(HttpStatus.SC_OK).body(customerDetailsDto);
    }


in ICustomerService interface

CustomerDetailsDto fetchCustomerDetails(String mobileNumber, String correlationId);

in CustomerServiceImpl

public CustomerDetailsDto fetchCustomerDetails(String mobileNumber, String correlationId) {
        Customer customer = customerRepository.findByMobileNumber(mobileNumber).orElseThrow(
                () -> new ResourceNotFoundException("Customer", "mobileNumber", mobileNumber)
        );
        Accounts accounts = accountsRepository.findByCustomerId(customer.getCustomerId()).orElseThrow(
                () -> new ResourceNotFoundException("Account", "customerId", customer.getCustomerId().toString())
        );

        CustomerDetailsDto customerDetailsDto = CustomerMapper.mapToCustomerDetailsDto(customer, new CustomerDetailsDto());
        customerDetailsDto.setAccountsDto(AccountsMapper.mapToAccountsDto(accounts, new AccountsDto()));

        ResponseEntity<LoansDto> loansDtoResponseEntity = loansFeignClient.fetchLoanDetails(correlationId, mobileNumber);
        customerDetailsDto.setLoansDto(loansDtoResponseEntity.getBody());

        ResponseEntity<CardsDto> cardsDtoResponseEntity = cardsFeignClient.fetchCardDetails(correlationId, mobileNumber);
        customerDetailsDto.setCardsDto(cardsDtoResponseEntity.getBody());

        return customerDetailsDto;

    }


inside Feign client interfaces

public ResponseEntity<LoansDto> fetchLoanDetails(@RequestHeader("ctsbank-correlation-id")
                                                         String correlationId, @RequestParam String mobileNumber);




inside LoansController

@GetMapping("/fetch")
public ResponseEntity<LoansDto> fetchLoanDetails(@RequestHeader("ctsbank-correlation-id") String correlationId,
                                                                @RequestParam
                                                               @Pattern(regexp="(^$|[0-9]{10})",message = "Mobile number must be 10 digits")
                                                               String mobileNumber) {
        logger.debug("ctsBank-correlation-id found: {} ", correlationId);
        LoansDto loansDto = iLoansService.fetchLoan(mobileNumber);
        return ResponseEntity.status(HttpStatus.OK).body(loansDto);
    }


inside CardsCotroller also same changes


application.yml of all microservices
logging:
 level:
  com:
   cognizant:
    accounts: debug    --- base package


FetchCustomerDetails 



