accounts  - microservice

Step -1

Create a New Spring Starter Project   OR   start.spring.io

Project Name: accounts
Package Name: com.wipro.accounts

Dependencies: Spring Web, Spring Boot DevTools, H2, Spring Data JPA, Validation, Lombok, Actuator (to monitor our microservice)


src/main/resources/application.yml

server:
  port: 8080
spring:
  datasource:
    url: jdbc:h2:mem:accountsdb
    driverClassName: org.h2.Driver
    username: admin
    password: 1234
  h2:
    console:
      enabled: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: true

Step # 2

Data Model

customer table ---> customer_id, name, email, mobile_number, created_at, created_by, updated_at, updated_by
accounts table ---> account_number, customer_id, account_type, branch_address, created_at, created_by, updated_at, updated_by


src/main/resources/schema.sql  ---- optional - not mandatory as we have provided ddl-auto in application configuration

CREATE TABLE IF NOT EXISTS customer (
  customer_id int AUTO_INCREMENT PRIMARY KEY,
  name varchar(100) NOT NULL,
  email varchar(100) NOT NULL,
  mobile_number varchar(20) NOT NULL,
  created_at date NOT NULL,
  created_by varchar(20) NOT NULL,
  updated_at date DEFAULT NULL,
  updated_by varchar(20) DEFAULT NULL
);

CREATE TABLE IF NOT EXISTS accounts (
  account_number int PRIMARY KEY,
  customer_id int NOT NULL,  
  account_type varchar(100) NOT NULL,
  branch_address varchar(200) NOT NULL,
  created_at date NOT NULL,
  created_by varchar(20) NOT NULL,
  updated_at date DEFAULT NULL,
  updated_by varchar(20) DEFAULT NULL
);

Step #3 --- writing spring data jpa entities & repositories to interact with DB table -----

--- BaseEntity.java -----------
createdAt, createdBy, updatedAt, updatedBy

package com.wipro.accounts.entity;

@MappedSuperclass 
@EntityListeners(AuditingEntityListener.class)
@Data
public class BaseEntity {
    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @CreatedBy
    @Column(updatable = false)
    private String createdBy;

    @LastModifiedDate
    @Column(insertable = false)
    private LocalDateTime updatedAt;

    @LastModifiedBy
    @Column(insertable = false)
    private String updatedBy;
}


----- Customer.java ------
customerId, name, email, mobileNumber

@Entity
@Getter
@Setter
@ToString
@AllArgsConstructor 
@NoArgsConstructor
public class Customer extends  BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name="customer_id")
    private Long customerId;

    private String name;

    private String email;

    @Column(name="mobile_number")
    private String mobileNumber;
}


------------ Accounts.java ------------
@Entity
@Getter
@Setter
@ToString   -- no hashCode & equals
@AllArgsConstructor 
@NoArgsConstructor
public class Accounts extends  BaseEntity {
	
    @Id
    @Column(name="account_number")
    private Long accountNumber;
    
    @Column(name="customer_id")
    private Long customerId;

    @Column(name="account_type")
    private String accountType;

    @Column(name="branch_address")
    private String branchAddress;
}


Step #4 ---- create repository interfaces -----

package com.wipro.accounts.repository;
@Repository
public interface AccountsRepository extends JpaRepository<Accounts, Long> {

    Optional<Accounts> findByCustomerId(Long customerId);

    @Transactional
    @Modifying
    void deleteByCustomerId(Long customerId);
}


@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    Optional<Customer> findByMobileNumber(String mobileNumber);
}



---- DTO (Data Transfer Object) Pattern -----

--> think of a situation where a customer wants to send customer information and accounts information in a single request or think of a situation where we need to send back Customer & Accounts details in a response entity (we can send only a single object in a response)
--> never use entity classes for data transfer - to overcome this we use DTO pattern
--> DTO classes can be used for data filtering


Step #5 ------- Creating DTO inside accounts microservice -----------

---------- CustomerDto.java -------

@Data
public class CustomerDto {
    private String name;
    private String email;
    private String mobileNumber;
}

-------- AccountsDto.java ----------

package com.wipro.accounts.dto;
@Data
public class AccountsDto {
    private Long accountNumber;
    private String accountType;
    private String branchAddress;
}



----- ResponseDto.java ----------
@Data 
@AllArgsConstructor
public class ResponseDto {
    private String statusCode;
    private String statusMsg;    
}

---------- ErrorResponseDto.java -------------
@Data 
@AllArgsConstructor
public class ErrorResponseDto {
    private  String apiPath;
    private HttpStatus errorCode;
    private  String errorMessage;
    private LocalDateTime errorTime;
}


Step #6 --- create constants class

------ AccountsConstants.java -----
package com.wipro.accounts.constants;
public class AccountsConstants {

    private AccountsConstants() {
        // restrict instantiation
    }

    public static final String  SAVINGS = "Savings";
    public static final String  ADDRESS = "Begumpet, Hyderabad, Telangana";
    public static final String  STATUS_201 = "201";
    public static final String  MESSAGE_201 = "Account created successfully";
    public static final String  STATUS_200 = "200";
    public static final String  MESSAGE_200 = "Request processed successfully";
    public static final String  STATUS_417 = "417";
    public static final String  MESSAGE_417_UPDATE= "Update operation failed. Please try again or contact Dev team";
    public static final String  MESSAGE_417_DELETE= "Delete operation failed. Please try again or contact Dev team";
    // public static final String  STATUS_500 = "500";
    // public static final String  MESSAGE_500 = "An error occurred. Please try again or contact Dev team";

}


Step # 7 ----- create API inside accounts microservice -------

----------- AccountsController.java --------
package com.wipro.accounts.controllers;

@RestController
@RequestMapping(path = "/api", produces = {MediaType.APPLICATION_JSON_VALUE})
public class AccountsController {
	
	@PostMapping("/create")
	public ResponseEntity<ResponseDto> createAccount(@RequestBody CustomerDto customerDto){

		return ResponseEntity
			.status(HttpStatus.CREATED)
			.body(new ResponseDto(AccountsConstants.STATUS_201, AccountsConstants.MESSAGE_201));
	}
}


Step #8 ---- create Mapper classes -------
---- AccountsMapper.java -------
package com.wipro.accounts.mapper;

public class AccountsMapper {

    public static AccountsDto mapToAccountsDto(Accounts accounts, AccountsDto accountsDto) {
        accountsDto.setAccountNumber(accounts.getAccountNumber());
        accountsDto.setAccountType(accounts.getAccountType());
        accountsDto.setBranchAddress(accounts.getBranchAddress());
        return accountsDto;
    }

    public static Accounts mapToAccounts(AccountsDto accountsDto, Accounts accounts) {
        accounts.setAccountNumber(accountsDto.getAccountNumber());
        accounts.setAccountType(accountsDto.getAccountType());
        accounts.setBranchAddress(accountsDto.getBranchAddress());
        return accounts;
    }

}

------ CustomerMapper.java -------
package com.wipro.accounts.mapper;

public class CustomerMapper {

    public static CustomerDto mapToCustomerDto(Customer customer, CustomerDto customerDto) {
        customerDto.setName(customer.getName());
        customerDto.setEmail(customer.getEmail());
        customerDto.setMobileNumber(customer.getMobileNumber());
        return customerDto;
    }

    public static Customer mapToCustomer(CustomerDto customerDto, Customer customer) {
        customer.setName(customerDto.getName());
        customer.setEmail(customerDto.getEmail());
        customer.setMobileNumber(customerDto.getMobileNumber());
        return customer;
    }

}
 -----> can use ModelMapper / BeanUtil dependencies  <-----


Step #9 ---- create service layer ----------

package com.wipro.accounts.service;
public interface IAccountsService {
    /**
     *@param customerDto - CustomerDto Object	
    */
    void createAccount(CustomerDto customerDto);
}

-------- AccountsServiceImpl.java ------------

package com.wipro.accounts.service;
@Service
@AllArgsConstructor
public class AccountsServiceImpl implements IAccountsService {
	private AccountsRepository accountsRepo;
	private CustomerRepository customerRepo;

	@Override
	public void createAccount(CustomerDto customerDto) {
		Customer customer = CustomerMapper.mapToCustomer(customerDto, new Customer());
		Customer savedCustomer = customerRepo.save(customer);
		
		accountsRepo.save(createNewAccount(savedCustomer));
	}

	/**
	 * @param customer - Customer Object
	 * @return the new account details
	 */
	private Accounts createNewAccount(Customer customer) {
		Accounts newAccount = new Accounts();
		newAccount.setCustomerId(customer.getCustomerId());
		long randomAccNumber = 1000000000L + new Random().nextInt(900000000);

		newAccount.setAccountNumber(randomAccNumber);
		newAccount.setAccountType(AccountsConstants.SAVINGS);
		newAccount.setBranchAddress(AccountsConstants.ADDRESS);
		return newAccount;
	}
}

---> we dont want to create a new account for a customer with same mobileNumber

Step #10  ---- create userdefined exceptions -------
------- CustomerAlreadyExistsException.java --------

package com.wipro.accounts.exception;

@ResponseStatus(value = HttpStatus.BAD_REQUEST)
public class CustomerAlreadyExistsException extends RuntimeException {

    public CustomerAlreadyExistsException(String message) {
        super(message);
    }
}


===> in service class -- we are checking whether a customer exists with the same mobile no

Optional<Customer> optionalCustomer = customerRepo.findByMobileNumber(customerDto.getMobileNumber());
if(optionalCustomer.isPresent()) {
       throw new CustomerAlreadyExistsException("Customer already registered with given mobileNumber " +customerDto.getMobileNumber());
}

==> add the method in CustomerRepository interface


Step #11  ---- create Global Exception Handler ----------

------ GlobalExceptionHandler.java -------

package com.wipro.accounts.exception;

@ControllerAdvice
public class GlobalExceptionHandler{

@ExceptionHandler(CustomerAlreadyExistsException.class)
    public ResponseEntity<ErrorResponseDto> handleCustomerAlreadyExistsException(CustomerAlreadyExistsException exception, WebRequest webRequest){
        ErrorResponseDto errorResponseDTO = new ErrorResponseDto(
                webRequest.getDescription(false), 
                HttpStatus.BAD_REQUEST,
                exception.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(errorResponseDTO, HttpStatus.BAD_REQUEST);
    }
}

webRequest.getDescription(false) -- //only api path , true - all details with IP

--- in AccountsController 

@AllArgsConstructor

private IAccountsService service;

@RestController
@AllArgsConstructor
@RequestMapping(path = "/api", produces = {MediaType.APPLICATION_JSON_VALUE})
public class AccountsController {
	private IAccountsService service;
	
	@PostMapping("/create")
	public ResponseEntity<ResponseDto> createAccount(@RequestBody CustomerDto customerDto){
		service.createAccount(customerDto);
		return ResponseEntity
					.status(HttpStatus.CREATED)
					.body(new ResponseDto(AccountsConstants.STATUS_201, AccountsConstants.MESSAGE_201));
	}
}


Step #12 --- run the application and in postman

POST http://localhost:8080/api/create

{
    "name":"Sunil Joseph",
    "email":"sunil@gmail.com",
    "mobileNumber":"9848586878"
}

error comes - NULL not allowed for column "CREATED_AT"; SQL statement

in service class --
customer.setCreatedAt(LocalDateTime.now());
customer.setCreatedBy("Anonymous");
Customer savedCustomer = customerRepo.save(customer);

-- same for Account
newAccount.setCreatedAt(LocalDateTime.now());
newAccount.setCreatedBy("Anonymous");

-- run again
-- run again with the same mobileNumber

-- check in DB


Step #13 ---- READ API inside accounts microservice -----

in IAccountService interface
    /**
     *
     * @param mobileNumber - Input Mobile Number
     * @return Accounts Details based on a given mobileNumber
     */
    CustomerDto fetchAccount(String mobileNumber);


in Service implementation
    /**
     * @param mobileNumber - Input Mobile Number
     * @return Accounts Details based on a given mobileNumber
     */
    @Override
    public CustomerDto fetchAccount(String mobileNumber) {
        Customer customer = customerRepository.findByMobileNumber(mobileNumber).orElseThrow(
                () -> new ResourceNotFoundException("Customer", "mobileNumber", mobileNumber)
        );
        Accounts accounts = accountsRepository.findByCustomerId(customer.getCustomerId()).orElseThrow(
                () -> new ResourceNotFoundException("Account", "customerId", customer.getCustomerId().toString())
        );
        CustomerDto customerDto = CustomerMapper.mapToCustomerDto(customer, new CustomerDto());
        customerDto.setAccountsDto(AccountsMapper.mapToAccountsDto(accounts, new AccountsDto()));
        return customerDto;
    }


----- ResourceNotFoundException.java -------
@ResponseStatus(value = HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String resourceName, String fieldName, String fieldValue) {
        super(String.format("%s not found with the given input data %s : '%s'", resourceName, fieldName, fieldValue));
    }
}


in GlobalExceptionHandler

   @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponseDto> handleResourceNotFoundException(ResourceNotFoundException exception, WebRequest webRequest) {
        ErrorResponseDto errorResponseDTO = new ErrorResponseDto(
                webRequest.getDescription(false),
                HttpStatus.NOT_FOUND,
                exception.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(errorResponseDTO, HttpStatus.NOT_FOUND);
    }


in CustomerDto -- add a new filed private AccountsDto accountsDto;

in controller

   @GetMapping("/fetch")
    public ResponseEntity<CustomerDto> fetchAccountDetails(@RequestParam String mobileNumber) {
        CustomerDto customerDto = iAccountsService.fetchAccount(mobileNumber);
        return ResponseEntity.status(HttpStatus.OK).body(customerDto);
    }

http://localhost:8080/api/fetch?mobileNumber=xxxxxxx


Step #14 ---- UPDATE API inside accounts microservice ----- dont allow to update the a/c number

Step #15 ---- DELETE API inside accounts microservice -----


Step #16 ---- Handle all types of runtime exceptions using global logic inside accounts -----

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDto> handleGlobalException(Exception exception, WebRequest webRequest) {
        ErrorResponseDto errorResponseDTO = new ErrorResponseDto(
                webRequest.getDescription(false),
                HttpStatus.INTERNAL_SERVER_ERROR,
                exception.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(errorResponseDTO, HttpStatus.INTERNAL_SERVER_ERROR);
    }

-- remove @AllArgsConstructor in AccountsController


Step #17 ---- Perform input data validations inside accounts microservice -----

public class CustomerDto {
    @NotEmpty(message = "Name can not be a null or empty")
    @Size(min = 5, max = 30, message = "The length of the customer name should be between 5 and 30")
    private String name;

    @NotEmpty(message = "Email address can not be a null or empty")
    @Email(message = "Email address should be a valid value")
    private String email;

    @Pattern(regexp = "(^$|[0-9]{10})", message = "Mobile number must be 10 digits")
    private String mobileNumber;
}


public class AccountsDto {
    @NotEmpty(message = "AccountNumber can not be a null or empty")
    @Pattern(regexp="(^$|[0-9]{10})",message = "AccountNumber must be 10 digits")
    private Long accountNumber;

    @NotEmpty(message = "AccountType can not be a null or empty")
    private String accountType;

    @NotEmpty(message = "BranchAddress can not be a null or empty")
    private String branchAddress;
}

in controller - @Validated -- class level (will tell to spring boot framework to perform validations on all the rest apis that we have defined inside AccountsController)

@Valid @RequestBody CustomerDto customerDto


for query parameter validations
fetchAccountDetails(@RequestParam @Pattern(regexp="(^$|[0-9]{10})",message = "Mobile number must be 10 digits")
  String mobileNumber) {



@ControllerAdvice
public class GlobalExceptionHandler  extends ResponseEntityExceptionHandler {

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
         MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {
        Map<String, String> validationErrors = new HashMap<>();
        List<ObjectError> validationErrorList = ex.getBindingResult().getAllErrors();

        validationErrorList.forEach((error) -> {
            	String fieldName = ((FieldError) error).getField();
            	String validationMsg = error.getDefaultMessage();
            	validationErrors.put(fieldName, validationMsg);
        });

        return new ResponseEntity<>(validationErrors, HttpStatus.BAD_REQUEST);
    }




Step #18 ---- Update audit columns using Spring data -----

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter 
@Setter 
@ToString
public class BaseEntity {

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @CreatedBy
    @Column(updatable = false)
    private String createdBy;

    @LastModifiedDate
    @Column(insertable = false)
    private LocalDateTime updatedAt;

    @LastModifiedBy
    @Column(insertable = false)
    private String updatedBy;
}



package com.wipro.accounts.audit;
@Component("auditAwareImpl")
public class AuditAwareImpl implements AuditorAware<String> {

    /**
     * Returns the current auditor of the application.
     *
     * @return the current auditor.
     */
    @Override
    public Optional<String> getCurrentAuditor() {
        return Optional.of("ACCOUNTS_MS");
    }	
}


-- to activate the auditing feature - we need to add an annotation to bootstrap class

@EnableJpaAuditing(auditorAwareRef = "auditAwareImpl")


-- remove the hard coded createdAt and createdBy set values from Service Impl





Step #18 ---- documentation of REST APIs using springdoc open api -----

@OpenAPIDefinition(
		info = @Info(
				title = "Accounts microservice REST API Documentation",
				description = "WiproBank Accounts microservice REST API Documentation",
				version = "v1",
				contact = @Contact(
						name = "Sunil Joseph",
						email = "sunil.j@wipro.com",
						url = "https://www.wipro.com"
				),
				license = @License(
						name = "Zetta 2.0",
						url = "https://www.wipro.com"
				)
		),
		externalDocs = @ExternalDocumentation(
				description =  "wiproBank Accounts microservice REST API Documentation",
				url = "https://www.wipro.com/swagger-ui.html"
		)
)

--- documentation using @Tag, @Operation, @ApiResponse

controller class
@Tag(
        name = "CRUD REST APIs for Accounts in WiproBank",
        description = "CRUD REST APIs in WiproBank to CREATE, UPDATE, FETCH AND DELETE account details"
)

on API

@Operation(
            summary = "Create Account REST API",
            description = "REST API to create new Customer &  Account inside WiproBank"
    )

@ApiResponses({
            @ApiResponse(
                    responseCode = "201",
                    description = "HTTP Status CREATED"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)
                    )
            )
    }
    )


-- documentaion of REST APIs using @Schema & example data

CustomerDto - class level
@Schema(
        name = "Customer",
        description = "Schema to hold Customer and Account information"
)


field level

@Schema(
            description = "Name of the customer", example = "Sunil Joseph"
    )
    @NotEmpty(message = "Name can not be a null or empty")
    @Size(min = 5, max = 30, message = "The length of the customer name should be between 5 and 30")
    private String name;

========================================================================================================

Build Loans Microservice

CREATE TABLE IF NOT EXISTS loans (
  loan_id int NOT NULL AUTO_INCREMENT,
  mobile_number varchar(15) NOT NULL,
  loan_number varchar(100) NOT NULL,
  loan_type varchar(100) NOT NULL,
  total_loan int NOT NULL,
  amount_paid int NOT NULL,
  outstanding_amount int NOT NULL,
  created_at date NOT NULL,
  created_by varchar(20) NOT NULL,
  updated_at date DEFAULT NULL,
  updated_by varchar(20) DEFAULT NULL,
  PRIMARY KEY (loan_id)
);

http://localhost:8090/api/create?mobileNumber=xxxxxxxxxxxxxxxxx

------  LoansDto.java -----
mobileNumber
loanNumber
loanType
totalLoan
amountPaid
outstandingAmount    





Build Cards Microservice

CREATE TABLE IF NOT EXISTS cards (
  card_id int NOT NULL AUTO_INCREMENT,
  mobile_number varchar(15) NOT NULL,
  card_number varchar(100) NOT NULL,
  card_type varchar(100) NOT NULL,
  total_limit int NOT NULL,
  amount_used int NOT NULL,
  available_amount int NOT NULL,
  created_at date NOT NULL,
  created_by varchar(20) NOT NULL,
  updated_at date DEFAULT NULL,
  updated_by varchar(20) DEFAULT NULL,
  PRIMARY KEY (card_id)
);

http://localhost:9000/api/create?mobileNumber=xxxxxxxx
----- CardsDto.java --------
mobileNumber  
cardNumber
cardType
totalLimit
amountUsed
availableAmount    ---- CardsDto


==========================================================================================================
Challenge #1  - developing microservice using REST API

Challenge #2  - How do we right size our microservices & identify boundaries

-- teashirt size S M L XL XXL  -- sizing is very important
user story stroy point

How to right size and identify service boundaries of microservices?

commands - is a process which will initiate the event
	ex: for the completed payment - customer has to click on a button to initiate the payment (command) and the reaction can be "the amount will be deducted from his a/c post the completion of the payment"

https://www.lucidchart.com/blog/ddd-event-storming



Sizing & Identifying boundaries with a ecommerce migration use case

Docker container inside Kuberneties Cluster

Event Bus (Event Streaming)- Kafka , Rabbit MQ

-----------------------------------------------------
Challenge # 3   Handle Deployment, Portability & Scalability of Microservices


What are Containers & How they are different from VMs?

 -- cloud computing
 -- VM - only virtual , we cannot see physically

Definition of Containers, Containerization, Docker

Docker Components & its architecture

<4.26.1

Docker Installation & Docker Hub

docker.com



Generate Docker Images - 3 approaches
1) Dockerfile
2) Buildpacks  
3) Google Jib

----------------------------------------------------------------------------------------------------
1) create a spring boot project
2) create a welcomerestcontroller and have a get mapping for /welcome
3) in pom.xml - provide <finalName>sb-docker.jar</finalName>, <packaging>jar....
4) package the application
    cmd>mvn clean install

5) check 
  to run the application
cmd>java -jar sb-docker.jar 

6) create a file with the name of "Dockerfile" in project folder

# start with a base image containing Java runtime
FROM openjdk:17-jdk-slim   

# information around who maintains the image
MAINTAINER wipro.com

# add the application's jar to the image
COPY target/sb-docker.jar sb-docker.jar

# execute the application
ENTRYPOINT ["java", "-jar", "sb-docker.jar"]   
    #whenever someone is trying to generate a container from my docker image - please execute 
         java -jar sb-docker.jar command


in addition
EXPOSE 5000    ----> Informs Docker about the port that the container listens on at runtime


7) create a docker image

cmd> docker build . -t 150478/sb-docker:1.0

150478 - docker account user name 
- with this command we are telling to docker server there is a Dockerfile inside this folder (. - current folder) - please use the instrucions and generate a docker image with the name specified
1.0 is the version (tag)

8) testing
cmd>docker images       docker image ls       docker image list


cmd> docker inspect image <image_id>   --> -- to know whether the docker image is created successfully based on the instructions in Dockerfile



to run the above image or to create a container

cmd>docker run -d -p 9090:8080 150478/sb-docker:1.0

 -p port mapping
 9090:8080 --- what we are telling to the docker server is -  my "docker container" is going to start in the port 8080 (second)
 where as with the first port we are telling to the docker - please expose the  container outside of the docker network at the port 9090; anyone wants to communicate with this container from outside of the docker network , they have to use the first port number in port mapping


cmd> docker ps 
cmd> docker ps -a    ---> all containers included killed ones


- stop the container
cmd>docker stop <container_id 5chars..>

-- to restart the container
cmd>docker start <stopped_container_id>

---------------------------------------------------------------------------
Pushing and Pulling Docker Image to/from Docker Hub

- Docker Hub is a Service provided by Docker for finding and sharing  your container images with your teams or with the general public	
https://hub.docker.com  & login

In Command Prompt:

cmd> docker login
username: 150478
password: 11Sxxxxx2


cmd> docker image ls

cmd>docker push <image_name_with_tag>

cmd>docker pull 150478/wipro:1.0


-- to create a new tag

cmd>docker tag <image_name> <dockerhub_user_name>/<image_name>:1.0.1

cmd>docker tag 150478/wipro:1.0 150478/wipro:1.1

cmd>docker push 150478/wipro:1.1
11782316
----------------------------------------------------------------------------------------------------

Generate Docker Image of Accounts Microservice with Dockerfile

pom.xml --- <packaging>jar</packaging>
<finalName>accounts</finalName>

In application.properties, add following setting --
 spring.h2.console.settings.web-allow-others=true


cmd>mvn -version
cmd>mvn clean install

---- to run the microservice -----
cmd>mvn spring-boot:run

cmd>java -jar target/account.jar

Create a file with name "Dokerfile" in project folder

# start with a base image containing Java runtime
FROM openjdk:17-jdk-slim   

# information around who maintains the image
MAINTAINER wipro.com

# add the application's jar to the image
COPY target/accounts.jar accounts.jar

# execute the application
ENTRYPOINT ["java", "-jar", "accounts.jar"]

#whenever someone is trying to generate a container from my docker image - please execute java -jar xxx.jar command



cmd>docker version
--- docker is installed corectly

cmd> docker build . -t 150478/accounts:v1

150478 - docker account user name - with this command we are telling to docker server there is a Dockerfile inside this folder - please use the instrucions and generate a docker image with the name specified

cmd> docker images

cmd> docker inspect image <image_id>
-- to know whether the docker image is created successfully based on the instructions in Dockerfile


--- Running Docker Image of accounts microservice with Dockerfile -----

cmd>docker run -p 8080:8080 150478/accounts:v1
 -p port mapping
 8080:8080 --- what we are telling to the docker server is -  my "docker container" is going to start in the port 8080 (second)
 where as with the first port we are telling to the docker - please expose the  container outside of the docker network at the port 8080; anyone wants to communicate with this container from outside of the docker network , they have to use the first port number in port mapping

cmd>docker run -d -p 8080:8080 150478/accounts:v1

cmd> docker ps 
cmd> docker ps -a    ---> all containers included killed ones


- stop the container
cmd>docker start <stopped_container_id>
---------------------------------------------------------------------------------


--- Challenges with Dockerfile approach to generate the Docker Image -----

1) we need to be an expert of docker to write the commands in Dockerfile - as a java developer (not DevOps engineer)- still we need to know the Dockerfile commands like FROM, MAINTAINER, COPY, ENTRYPOINT etc - think of a situation where the Dockerfile is large - lot of learning curve involved for the developer - why should java developer should know about it?

2) we should know the best practices for creating a Docker file - like the size should be as small as possible, caching, compression, security - our docker image should be secure

3) we need to put lot of efforts

---------------------------------------------------------------------------------


--- Generate Docker Image of Loans microservice with Buildpacks ------

What is buildpacks?
 https://buildpacks.io/

 using buildpacks we can transform our application source code into images that can run on any cloud; no need of writing low level instructions in Dockerfile; with a single maven command we can generate a docker image very easily

buildpacks is developed by Heroku - later Pivotal  joined with Hiroku

buildpacks will scan our source code , dependencies and accordingly it is going to generate the docker image 

https://paketo.io/
paketo buildpacks <--- implementation of  buildpacks


<packaging>jar</packaging>
<finalName>loans</finalName>

spring-boot-maven-plugin - inside pom.xml - we can create a docker image and this plugin internally uses paketo buildpacks to make production ready docker image

<plugins>
 <plugin>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-maven-plugin</artifactId>
   <configuration>
     <!-- provide docker image name -->
     <image>
	<name>150478/${project.artifactId}:v1</name>    150478/loans:v1
     </image>
     <excludes>
 	  <exclude>



cmd>mvn clean spring-boot:build-image

downloads paketobuildpacks for the first time

cmd>docker images 
--check the size of Dockerfile and buildpack images

cmd>docker run -d -p 8081:8090 150478/loans:v1

try with postman/ swagger


<image>
 <name>150478/${project.artifactId}:v1</name>
 <createdDate>${maven.build.timestamp}</createdDate>
</image>





----- Generate Docker Image of Cards microservice with Google Jib ---------

github.com/GoogleContainerTools/Jib

Jib is an open-source tool to containerize your Java applications, includes new features and is production-ready

Jib is going to work only for Java applications, where as buildpacks will work for other languages also

Jib organizes your application into distinct layers; dependencies, resources, and classes; and utilizes Docker image layer caching to keep builds fast by only rebuilding changes. Jib's layer organization and small base image keeps overall image size small which improves performance and portability.

Quick Start > Maven  -- Setup

<packaging>jar</packaging>
copy <plugin>

<build>
 <plugins>
  <plugin>
        <groupId>com.google.cloud.tools</groupId>
        <artifactId>jib-maven-plugin</artifactId>
        <version>3.4.1</version>
        <configuration>
          <to>
            <image>150478/${project.artifactId}:v1</image>
          </to>
        </configuration>
  </plugin>
 </plugins>
</build>


build your image
cmd> mvn compile jib:build

Build to Docker daemon
cmd>mvn compile jib:dockerBuild				cmd>docker logout

Subsequent builds are much faster than the initial build (buildpacks)

CREATED date may be 43 years something (old date)- its not a bug -  they make a start date some where 1983
cmd>docker images   --- check the sizes

cmd>docker run -d -p 9000:9000 150478/cards:v1

Advantage of Google Jib - we can create docker image even if docker is not installed
Jib can also build your image directly to a Docker daemon. This uses the docker command line tool and requires that you have docker available on your PATH.



---- Compare Dockerfile , Buildpacks, Jib approaches ----------

https://buildpacks.io/features/			---> Comparison


----- Pushing Docker Images from our local to remote Docker hub Repository ------

cmd>docker image push docker.io/150478/accounts:v1 
cmd>docker image push docker.io/150478/loans:v1 
cmd>docker image push docker.io/150478/cards:v1 

public view to private view in docker hub - settings - visibility settings - - only
- personal plan can have only one repository as private 

cmd>docker pull 150478/accounts:v1


---- Working with Docker Compose ------------------

Docker Compose is a component in the Docker ecosystem

Docker compose is used to handle multiple containers

When dealing with the execution of multiple containers utilizing the Docker CLI can be error-prone. Writing commands directly in a terminal window can introduce errors, make the code difficult to comprehend, and pose challenges when attempting to implement version control.

we have 3 microservice images - accounts, cards and loans - to run all these 3 -we need to convert the 3 docker images to containers using "docker run" command. To start the 3 containers we need to issue 3 docker run commands along with image name and port mappings - here comes the use of Docker Compose

https://docs.docker.com/compose/

Docker Compose is a tool for defining and running multi-container applications. It is the key to unlocking a streamlined and efficient development and deployment experience.


Compose works in all environments; production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application:
    - Start, stop, and rebuild services
    - View the status of running services
    - Stream the log output of running services
    - Run a one-off command on a service

Doker Compose will gets installed along with Docker Desktop

-- to install Docker compose if not available
https://docs.docker.com/compose/install/standalone/


cmd>docker compose version

practicals - create a file with name "docker-compose.yml" in any of our microservices - in accounts

services:
  accounts:
    image: "150478/accounts:v1"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - WiproBank
  loans:
    image: "150478/loans:v1"
    container_name: loans-ms
    ports:
      - "8090:8090"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - WiproBank
  cards:
    image: "150478/cards:v1"
    container_name: cards-ms
    ports:
      - "9000:9000"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - WiproBank
networks:
  WiproBank:
    driver: "bridge"

-----
accounts, cards, loans   -service name
container_name:  -- if we are not providing then it will be given with a default name
ports - port mapping
 - multiple elements can be  provided like an array , so that we need to provide -

accounts-ms we want provide max 700mb
networks:  - WiproBank  --> 

in this case there is no dependency between these 3 microservices - they are all going to start in isolated network

what if I have a dependency between these microservice ; or in future , each microservice need to talk to each other - in that scenario it is not going to work by default.

To make sure that the intercommunication is working - we need to tag all these microservices into a same network

networks - root element
  WiproBank:
    driver: "bridge"    -- we are telling to docker to create a network with name "WiproBank" with driver - bridge - so that our 3 microservices can communicate each other






---- Running All Microservice container using Docker Compose Command ------------------
accounts>cmd>docker compose up 
  OR
accounts>cmd>docker compose up -d      --- detached mode

cmd>docker ps

try running APIs in postman

cmd>docker compose down

cmd>docker ps
cmd>docker ps -a

cmd> docker compose up -d

cmd>docker compose stop
cmd>docker ps -a

cmd>docker compose start


---- Docker Commands ------------------
page 44


---- Docker extension- Logs Explorer ------------------

Logs Explorer Extension --> View all your container logs in one place so you can debug and troubleshoot faster

Docker Desktop Dashboard -- Add Extensions  - Logs Explorer  - Install
 - open
 - no logs information as there is no containers are up

cmd>docker compose up -d

check in Log Explorer Extension

===============================================================================

Cloud Native Apps & 12/15-Factor Methodology

-----------------------------------------

1) ------------ introduction to cloud-native applications ---------------

What are Cloud-native applications?

The layman definition:

Cloud-native applications are software applications designed specifically to leverage cloud computing principles and take full advantage of cloud-native technologies and services. These applications are built and optimized to run cloud environments, utlizing the scalability, elasticity, and flexibility offered by the cloud.

In simple words - cloud native applications are applications which are built for cloud environment, so that organizations can take complete advantage of cloud provided services and technologies.

Cloud native is the software approach of building, deploying, and managing modern applications in cloud computing environments. 

-- Official Definition by The Cloud Native Computing Foundation (CNCF)

 Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds (cloud environments can be anything like AWS, GCP, our own data center, Azure etc). Containers, Service meshes, microservices,immutable infrastructure, and declarative APIs exemplify this approach.



These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predicatbly with minimal toil (work/effort).



https://www.cncf.io/online-programs/what-is-cloud-native-and-why-does-it-exist/



----- Important Characteristics of cloud-native applications --------

page 47

1) Microservices
2) Containers
3) Scalability & Elasticity
4) DevOps Practices 
5) Resilience & Fault Tolerence
6) Cloud-Native Services





----- Difference between cloud-native Apps & Traditional enterprise Apps --------

Page 48


----- Development Principles of Cloud Native - 12-factors & Beyond --------

Page 49

12factor.net


1) One codebase, one application

2) Dependency Management

3) Design, build, release, run

4) Configuration, credentials & code

5) Logs

6) Disposability

7) Backing Services

8) Environment Parity - Dev/prod parity

9) Administrative Process

10) Port Binding

11) Stateless Processes

12) Concurrency

13) API First

14) Telemetry

15) Authentication & Authorization



1) One codebase for one application   (51)

 - as per this guideline - we need to make sure that there is one-to-one correspondance between an application and its code base- which means - each application/microservice need to have its own dedicated codebase.

In our case we build 3 microservices - accounts, loans and cards 

If there is any code which is common to multiple microservices - then such common code should be managed separately as a library or can be deployed as a separate standalone service which will serve as a backing service for the other microservices

Configurations requiremets for Dev, QA, Production should be done outside of the codebase - so that configurations can be injected externally during the deployments into your application codebase


2) API First  - 15 factor methodology

in microservices everything we develop as REST APIs

this methodology recommands you to always adopt and always have a mindset of API first- which means right from the design of cloud native application , we should always think like to write as much as logic as possible with the help of APIs only; so that each of the logic can be invoked by other APIs in other microservices


3) Dependency Management

It is important or crucial to declare all our dependencies needed for our application in a single manifest file and post the we should also ensure that these dependencies are accessible to a dependency manager which can download all of them from a central repository - maven / gradle - pom.xml / build.gradle

by following this approach we maintain a clear and controlled dependency management process for our application. If we are not following pom.xml or build.gradle and if we mannually download and integrate to application with build path - will make our application complex.

<image  - 53>

4) Design, build, release, run

inside this guideline the recommendation is - your codebase has to progress from design to production by following the below stages

 -> Design Stage - determine the technologies, dependencies, and tools for specific application features - also includes development and unit testing

 -> Build Stage - compile and package the codebase with dependencies with unique version id

 -> Release Stage - combine the build with a specific deployment configuration based upon the environment- for production release , production related configurations to be integrated with build

 -> Run stage - we need to run the application in the designated environment using the specific release

- no runtime code modification is allowed at run stage - only use immutable build


5) Configuration, Credentials & Code

what is configuration?

according to 15 factor methodology - configuration are the elements that are prone to change between the deployments. If there is a property which is going to differ from one environment to another environment - we call all these type of property or elements as configurations. 

we should never club configurations with our code base; we should have the ability to modify application configurations independently or without a need to rebuild the application for every environment

ex: DB properties, message system properties, credentials for accessing 3rd party APIs etc

<image 56>


github single codebase ---->   docker image  <---  injecting Dev Config or Testing Config or Prod configurations ----> for each environment 

we use spring cloud config server in spring cloud native ecosystem


6) Logs

inside a traditional application or a monolythic application - how the logs are handled? application will write the logs to a file in a folder location of our server; if there are any issue comes inside our monolythinc application - developer will go to the log location and find log of a specific date and do necessary corrections in code

but in microservices (100s of microservices) or in a spring cloud native application the above approach is not feasible

as per this methodology it is recommended that all the log routing and storage are not the application's concerns; microservices will not write the logs in any log folder or inside any log location ; instead application will simply redirect their logs to the  standard output treating them as a sequentially ordered events based upon the time. The responsibility of the log storage and rotation is now shifted to an external tool, known as "log aggregator". This tool retrieves, gathers and provides access to the logs for debuggings/ inspection purposes


<image - 56>


7) Disposability

inside a traditional monolythic application making sure that a single monolythic application is running with top priority; no room for the application to gets stopped or terminated.

ephemeral - if any microservice is unresponsible we can terminate and can be replaced with a new instance using platforms like Kubernetes automatically. and also in high load time we can spinup with more instances to cater the increased workload

this concept of shutting down and creating new instance automatically is known as application disposability


8) Backing Services

your microservices may have dependency on many other external resources like DB, SMTP, FTP Servers, or RESTful Web Services, Caching systems, message brockers - all these are called as backing resources - we should always treat them as attached to the resources that we can modify or replace them without needing to make any changes inside our application.


9) Environment Parity

as per this guiding principle - it is recommended to minimize the differences b/w various environments of our application. 


10) Administrative Processes
11) Port Binding
12) Stateless Process
13) Concurrency
14) Telemetry (15 factor methodology)
15) Authentication & Authorization - Security


===============================================================================

Configuration Management in Microservices

Challenge #4

--> Separation of Configurations/ properties
--> Inject Configs/ Properties
--> Maintain Configs/ Properties

Solutions:

1) Configuring Spring Boot with Properties and Profiles
2) Applying external configuration with Spring Boot
3) Implementing a Configuration Server with Spring Boot Cloud Config Server


---- How Configuration works in Spring Boot ---------
	application.properties or application.yml
--69


---- Reading configurations using @Value annotation ---------
accounts microservices
apply google jib maven plugin in all microservices

in application.yml and a new property

build:
  version: "1.0"

in controller class AccountsController

@Value("${build.version}")
private String buildVersion;



@GetMapping("/build-info")
public ResponseEntity<String> getBuildInfo() {
  return ResponseEntity
                .status(HttpStatus.OK)
                .body(buildVersion);
}

@Operation(
         summary = "Get Build information",
         description = "Get Build information that is deployed into accounts microservice")

@ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "HTTP Status OK"),

            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)))
    } )


run the app
http://localhost:8080/api/build-info


---- Reading configurations using Environment Interface ---------

why to go for environment variables - cant we use application.properties
- incase of some sensitive informations like passwords - we dont want to define it in properties - use Environment variables - only server admins have access to env variables

in AccountsController
@Autowired
private Environment environment

@Operation(summary = "Get Java version",
           description = "Get Java versions details that is installed into accounts microservice")

@ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "HTTP Status OK"),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(schema = @Schema(implementation = ErrorResponseDto.class)))
	  })

@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
     return ResponseEntity
              .status(HttpStatus.OK)
              .body(environment.getProperty("JAVA_HOME"));
}



---- Reading configurations using @ConfigurationProperties annotation ---------

in application.yml

accounts:
  message: "Welcome to WiproBank accounts related APIs"
  contactDetails:
    name: "Sunil Joseph - Developer"
    email: "sunil@WiproBank.com"
  onCallSupport:
    - (40) 238-41700
    - (40) 238-41701


create a Record in dto package --- AccountsContactInfoDto.java  

@ConfigurationProperties(prefix = "accounts")
public record AccountsContactInfoDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) { }


in Controller class

@Autowired
private AccountsContactInfoDto accountsContactInfoDto;

    @Operation(
            summary = "Get Contact Info",
            description = "Contact Info details that can be reached out in case of any issues")
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "HTTP Status OK"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)
                    )
            ) } )

    @GetMapping("/contact-info")
    public ResponseEntity<AccountsContactInfoDto> getContactInfo() {
        return ResponseEntity
                .status(HttpStatus.OK)
                .body(accountsContactInfoDto);
    }

on bootstrap class
@EnableConfigurationProperties(value = {AccountsContactInfoDto.class})




---- Using Spring Boot Profiles ---------
page - 70

application_prod.properties
application_qa.properties

spring.profiles.active=dev

Practicals

application_prod.yml

spring:
  config:
    activate:
      on-profile: "prod"
build:
  version: "1.0"

accounts:
  message: "Welcome to WiproBank accounts related prod APIs "
  contactDetails:
    name: "Valerie - Product Owner"
    email: "valerie@WiproBank.com"
  onCallSupport:
    - (453) 392-4829
    - (236) 203-0384

application_qa.yml

spring:
  config:
    activate:
      on-profile: "qa"

build:
  version: "2.0"

accounts:
  message: "Welcome to WiproBank accounts related QA APIs "
  contactDetails:
    name: "Sanjay - QA Lead"
    email: "sanjay@WiproBank.com"
  onCallSupport:
    - (040) 265-3765
    - (040) 734-8371


in application.yml
spring:
 config:
   import:
    - "application_qa.yml"
    - "application_prod.yml"

 profiles:
   active:
    - "qa"


---- Externalizing configurations using commandline, JVM, & environment options ---------

in the above approach we need to make changes to application.yml everytime to specify the environment - need to regenerate the docker image

page 71

a) how to externalize configurations using commandline argument
cmd> java -jar target/accounts.jar --build.version="9.1"
     java -jar target/accounts.jar --build.version=9.1

	http://localhost:8080/api/build-info

b) how to externalize configurations using JVM System Properties

cmd>java -Dbuild.version="1.2" -jar accounts.jar

c) how to externalize configurations using environment variables  - 73
widely used as they are universally supportted
no lower case value only uppercase "build.version" to "BUILD_VERSION"

cmd>env:BUILD_VERSION="1.3";java -jar accounts.jar
	OR
cmd>set BUILD_VERSION=1.3      -- to declare an environment variable temporarly
cmd>java -jar accounts.jar


---- Activating the profile using commandline, JVM & environment options externally ---------

a) using command line
Run As --> Run Configurations
	--spring.profiles.active=prod

b) using JVM system variables
Run Configurations - VM Arguments
	-Dspring.profiles.active=prod
	-Dbuild.version=1.3

c) environment variables
Run Configurations -- Environment (tab)
SPRING_PROFILES_ACTIVE=prod;BUILD_VERSION=1.3


-------------- Assignment to make Spring Boot profile changes inside loans & cards microservices ----------------------

---- Drwabacks of externalized configurations using SpringBoot alone ----
page 73



====== Spring Cloud Config  ======

Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system.

we have seen how to manage configurations with spring boot alone. 
we maintain the configurations along with spring boot - it has got lot of issues and limitations.
we are going to see a better approach or the recommended approach we need to use - by using spring cloud config of spring ecosystem just maintain the configurations inside any cloud native system like microservices or any cloud applications.

In this approach we are going to have a centralized configuration server - which means we need to build a separate application that is going to act as a configuration server with the help of spring cloud config. using this centralized config server we can overcome all the limitations and drawbacks of the previous approach.
this approach will provide support for server and client for externalized configurations in a distributed system like microservices.

all our microservices should be registered as clients with this config server and this can act as a centralized config server.

https://spring.io   -- projects  -- Spring Cloud  -- Spring Cloud Config


What is Spring Cloud?

Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system.




--------- Building Config Server using Spring Cloud ---------------

New Spring Boot Starter Project  - configserver
Config Server for WiproBank microservices

Dependencies : Config Server , Actuator, 
config server dependency (spring-cloud-config-server) - Central management for configuration via Git, SVN, or HashiCorp Vault etc.

pom.xml

  https://spring.io/projects/spring-cloud

on bootstrap class  - @EnableConfigServer

application.yml

server:
  port: 8071

now our config server is available inside our microservices network. as of now there is no place for our config server to read the configurations; - we need to move all the required configurations of our microservices to a centralized location and we need to configure the centralized location inside our config server - so that our config server will start reading the configuration details  - there are multiple options available like classpath, filesystem, github repo, database, cloud like AWS S3 etc


------ Reading configurations from the classpath location of Config Server ------

application.yml

spring:
  application:
    name: "configserver"

src/main/resources/config
 place properties.yml, properties_prod.yml, properties_qa.yml from accounts microservices and rename to accounts.yml, accounts-prod.yml, accounts-qa.yml etc

 ---> in all the files we maintain only the "build" and "accounts" elements

same for loans and cards in configserver

-- add an additional property in application.yml
spring:
 profiles:
  active: native    -- telling to spring cloud config server that we want to activate a native profile of 			spring cloud 			config server (mainly for classpath)


spring.cloud.config.server.native.search-locations="classpath:/config"

Run as Spring boot application
in browser - http://localhost:8071/accounts/prod
	     http://localhost:8071/accounts/qa

to display json data in a proper manner in browser - JSONView
 


------ Updating accounts microservices to read properties from Config Server ------

task -> connect our accounts microservice to config server 
in accounts ms - delete _prod and _qa yml files

-- add a new dependency in pom.xml of accounts ms   ---> Config Client   
spring-cloud-starter-config - Client that connects to a Spring Cloud Config Server to fetch the application's configuration.


in application.yml
keep only 
 server.port

 spring.datasource
 spring.h2
 spring.jpa			delete - spring.config.import


add the following properties
spring.application.name = "accounts"     --- should match with accounts-prod, accounts-qa etc
spring.profiles.active="prod"

spring.config.import= "optional:configserver:http://localhost:8071/"

-- run accounts ms - this will go and connect to config server
-- check the logs

http://localhost:8080/api/build-info
http://localhost:8080/api/contact-info

------------------------------------
accounts - application.yml

server:
  port: 8080
spring:
  application:
    name: "accounts"
  profiles:
    active: "prod"    
  datasource:
    url: jdbc:h2:mem:testdb
    driverClassName: org.h2.Driver
    username: sa
    password: ''
  h2:
    console:
      enabled: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: true
  config:
   import: "optional:configserver:http://localhost:8071/"   

------------------------------------
configserver - application.yml

spring:
  application:
    name: "configserver"
  profiles:
    active: native
  cloud:
    config:
      server:
        native:
          search-locations: "classpath:/config" 
server:
  port: 8071    

-----------------------------------------------

case 2
provide the active profile externally as commandline argument 
Run Configurations  --spring.profiles.active=qa

-----------------------------------------------

Task ===> Update Loans & Cards Microservices to read the properties from ConfigServer




---------------- Reading configurations from a file system location --------------

advantage - the details can be placed in the server where the microservice is deployed


place all the files of src/main/resources/config to a folder location like C:\wipro\config

in application.yml of configserver

spring.cloud.config.server.native.search-locations="file:///wipro/config"



---------------- Reading configurations from a GitHub Repository --------------

--> most recommended approach 
advantages --> we can properly secure the GitHub Repo - so that no one can access it
           --> it supports versioning, auditing
           --> in future we can check what property we have used last year (we can see the GitHub History) 	

1) move all the properties to a GitHub repo
create a new repo -> zetta-config
push all accounts, loans and cards yml files

2) application.yml of config server

spring.profiles.active=git

spring.cloud.config.server.git.uri="https://github.com/suniledureka/zetta-config.git"
spring.cloud.config.server.git.default-label: main    	-- to specify the branch
spring.cloud.config.server.git.timeout: 5 		-- 5 seconds throw exception after
spring.cloud.config.server.git.clone-on-start: true	-- telling config server to clone the repo to local system in the startup itself; other wise cloning will happen only when the first request comes to config server

spring.cloud.config.server.git.force-pull: true		-- telling to override all the local changes in the local repository 


Run all microservices and test in postman  - check logs

http://localhost:8071/accounts/prod

http://localhost:8080/api/contact-info


https://docs.spring.io/spring-cloud-config/reference/   -- Git Backend -- Authentication (for private GitHub Repository)




------- Encryption and Decryption of properties inside Config Server ---------

in application.yml of configserver

encrypt:
  key: "45D81EC1EF61DF9AD8D3E5BB397F9"   -- secret key

run config server
in postman
POST  - http://localhost:8071/encrypt
Body -- Raw -- Text   sunil@wipro.com

in accounts-prod.yml
email: "{cipher}xxxxxx"

restart application

http://localhost:8071/accounts/qa

http://localhost:8080/api/contact-info

POST - http://localhost:8071/decrypt  
encrypted text data

==========================================================================================================



Dockerizing Spring Boot Application with MySQL using Docker compose
===================================================================

Practicals:

1) Create a Spring Boot Application in STS
   sb-mysql-docker
   Dependencies: Spring Web, MySQL Driver, Spring Data JPA, Lombok

srs/main.resources/application.properties

# Server port
server.port=8090
 
# Datasource connection
spring.sql.init.platform=mysql
spring.sql.init.mode=always
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.sql.init.continue-on-error=true

# Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
 
# Logging
logging.level.org.springframework=ERROR
logging.level.com.numericaideas=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE


2) src/main/resources/schema.sql
CREATE TABLE IF NOT EXISTS persons(
    id bigint(20) NOT NULL AUTO_INCREMENT,
    name varchar(255) DEFAULT NULL,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

src/main/resources/data.sql

INSERT  INTO persons(name) VALUES('Sanjay');
INSERT  INTO persons(name) VALUES('Praveen');



Create entity class

@Entity
@Table(name = "person")
@Getter
@Setter
@ToString
public class Person {
	@Id
	@Column(name = "id")
	private Integer personId;
	
	@Column(name = "name")
	private String personName;
}


Create Repository

public interface PersonRepository extends JpaRepository<Person, Integer> {}

Create Service component

@Service
@AllArgsConstructor
public class PersonService {
	private PersonRepository repo;
	
	public List<Person> getAllEntities(){
		return repo.findAll();
	}
}

Create Controller
@RestController
@AllArgsConstructor
public class PersonRestController {
	private PersonService personService;

	@GetMapping("/all")
	public List<Person> getAll() {
		return personService.getAllEntities();
	}

}

package the application
cmd>mvnw clean install
  OR
Run As - Maven install



2) Create Docker Image for Spring Boot Application - 
create a file with name "Dockerfile" in the project folder

# Use a base image with Java 17
FROM openjdk:17
 
# Copy the JAR package into the image
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
 
# Expose the application port
EXPOSE 8090
 
# Run the App
ENTRYPOINT ["java", "-jar", "/app.jar"]



3) Create docker image  [not mandatory]
cmd> docker build .	


4) Docker Compose Spring Boot and MySQL

Docker Compose simplifies the orchestration of multi-container applications. 

Create a file named "docker-compose.yml" in your project directory and add the following configuration:

version: '3.7'
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 8090:8090
    depends_on:
      mysqldb:
        condition: service_healthy
    environment:
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysqldb:3306/${MYSQL_DATABASE}?allowPublicKeyRetrieval=true
      - SPRING_DATASOURCE_USERNAME=root
      - SPRING_DATASOURCE_PASSWORD=${MYSQL_PASSWORD}
    networks:
      - springboot-mysql-network
  mysqldb:
    image: mysql:8.0.33
    ports:
      - 3306:3306
    environment:
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_ROOT_PASSWORD=${MYSQL_PASSWORD}
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - springboot-mysql-network
    healthcheck:
      test: ["CMD", "mysqladmin" ,"ping", "-h", "localhost"]
      retries: 10
      interval: 3s
      timeout: 30s
volumes:
  mysql-data:
networks:
  springboot-mysql-network:
    name: springboot-mysql-network

version: Version of Docker Compose file format.
services: My application has two services: app (Spring Boot) and mysqldb (MySQL database image).
build: Configuration options that are applied at build time that we defined in the Dockerfile with relative path
image: Official Docker image from docker hub
volumes: Named volumes that keeps our data alive after restart.
network: The two services should be belong to one network.
depends_on: Dependency order, mysqldb is started before app
++Important : The data base host name should be replaced by data base service name. Ex : jdbc:mysql://mysqldb:3306/${MYSQL_DATABASE}


5) create a file with name ".env" in the place of Dockerfile
MYSQL_DATABASE=mydatabase
MYSQL_PASSWORD=rootpassword



This Docker Compose configuration defines two services: 
 "app" for the Spring Boot Application and 
 "mysqldb" for the MySQL database. 

The app service builds the image based on the Dockerfile in the project's root directory. 

The mysqldb service uses the official MySQL image and sets the environment variables for the database configuration. 

The "depends_on" attribute ensures that the Spring Boot application starts after the MySQL database in order to guarantee dependency ordering. 

Finally, the healthcheck makes sure the MySQL service is ready to accept connections before running the App.


Spring Boot automatically assigns these variables to the related application.properties configurations listed below:

    spring.datasource.url
    spring.datasource.username
    spring.datasource.password 
- meaning we don't have to provide these manually into the application.properties file


6) Run the Dockerized Application

cmd> docker compose up
docker compose up -e MYSQL_DATABASE=mydatabase -e MYSQL_PASSWORD=rootpassword

7)
cmd>docker ps



8) to log into mysql container
cmd> docker exec -it sb-mysql-docker-mysqldb-1 bash
#mysql -u root -p
password: rootpassword

mysql> show databases;
mysql> use .....
mysql> show tables;


Reference: https://numericaideas.com/blog/docker-compose-springboot-mysql/


Login in to created containers using :
cmd> docker exec sb-mysql-docker-app-1 bin/sh

-------------------------------------------------------------------------------------
In here schema.sql (DDL queries) file added to create table structure and data.sql file added to load data (DML queries) while populate to spring application.


1) Create spring boot application and connect it with MySQL DB.
2) Create Dockerfile to Spring boot application.
3) Create docker compose configuration file
4) Run the system and inspect running containers


1) Create a Spring Boot Application
 Spring Web, Spring Data JPA, MySQL Connector

2) application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase?allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=rootpassword
spring.jpa.hibernate.ddl-auto=update

spring.sql.init.mode=always 
spring.sql.init.continue-on-error=true
spring.datasource.initialization-mode=always

2) src/main/resources/schema.sql
CREATE TABLE IF NOT EXISTS persons(
    id bigint(20) NOT NULL AUTO_INCREMENT,
    name varchar(255) DEFAULT NULL,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

src/main/resources/data.sql

INSERT  INTO persons(name) VALUES('Sanjay');
INSERT  INTO persons(name) VALUES('Praveen');

3) Repository & Services

4) Controller
@RestController
public class BasicController {
 
 @Autowired
 private PersonService personService;
 @GetMapping("/all")
 public List<Persons> getAll() { 
  return personService.findAll();
 }
}


5) Docker file
#
# Build stage
#
FROM maven:3.8.3-openjdk-17 AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package
EXPOSE 8080
ENTRYPOINT ["java","-jar","/home/app/target/spring_rest_docker.jar"]

FROM : Fetching latest version of Java image with maven. This pre define docker image exists on docker hub.
COPY : Copying Project src folder to openjdk-17 containers root directory /home/app/src.Copy again pom.xml file to /home/app/.
RUN : Execute the mavean command to build the .jar file accoring to given pom.xml file.
EXPOSE : Specify that expose server port
ENTRYPOINT : Execute command for run the .jar file.We can use CMD instead of ENTRYPOINT.If we use CMD we can provide arguments to image when build it.

6) docker-compose.yaml or .yml

version: "3.7"
services:
  api_service:
    build: .
    restart: always
    ports:
      - 8080:8080
    networks:
      - springapimysql-net
    environment:
      - spring.datasource.url=jdbc:mysql://mysqldb:3306/mydatabase?allowPublicKeyRetrieval=true    
    depends_on:
      - mysqldb
    
    volumes:
      - .m2:/root/.m2
      
  mysqldb:
    image: "mysql:8.0"
    restart: always
    ports:
      - 3306:3306
    networks:
      - springapimysql-net  
    environment:
      MYSQL_DATABASE: mydatabase
      MYSQL_USER: root
      MYSQL_PASSWORD: root
      MYSQL_ROOT_PASSWORD: root
networks:
  springapimysql-net:


version: Version of Docker Compose file format.
services: My application has two services: app (Spring Boot) and mysqldb (MySQL database image).
build: Configuration options that are applied at build time that we defined in the Dockerfile with relative path
image: Official Docker image from docker hub
volumes: Named volumes that keeps our data alive after restart.
network: The two services should be belong to one network.
depends_on: Dependency order, mysqldb is started before app
++Important : The data base host name should be replaced by data base service name. Ex : jdbc:mysql://mysqldb:3306/mydatabase?


run it

cmd> docker-compose up

cmd> docker images

cmd> docker ps -a

Login in to created containers using :
api_service container = docker exec -it basic-api_service-1 bin/sh

cmd> docker exec -it basic-api_service-1 bin/sh
#ls
#cd home/app
#ls
#cd target
#ls



cmd> docker exec -it basic-mysqldb-1 bash
#mysql -u root -p

http://localhost:8080/all
===========================================================================================================






   @GetMapping("/fetch")
   public ResponseEntity<CustomerDto> fetchAccountDetails(@RequestParam
                                                               @Pattern(regexp="(^$|[0-9]{10})",message = "Mobile number must be 10 digits")
                                                               String mobileNumber) {
        CustomerDto customerDto = iAccountsService.fetchAccount(mobileNumber);
        return ResponseEntity.status(HttpStatus.OK).body(customerDto);
    }

Step #14 ---- UPDATE API inside accounts microservice -----

Step #15 ---- DELETE API inside accounts microservice -----





@Service
@AllArgsConstructor
public class AccountsServiceImpl  implements IAccountsService {

    private AccountsRepository accountsRepository;
    private CustomerRepository customerRepository;

    /**
     * @param customerDto - CustomerDto Object
     */
    @Override
    public void createAccount(CustomerDto customerDto) {
        Customer customer = CustomerMapper.mapToCustomer(customerDto, new Customer());

        Optional<Customer> optionalCustomer = customerRepository.findByMobileNumber(customerDto.getMobileNumber());
        if(optionalCustomer.isPresent()) {
            throw new CustomerAlreadyExistsException("Customer already registered with given mobileNumber "+customerDto.getMobileNumber());
        }
        Customer savedCustomer = customerRepository.save(customer);
        accountsRepository.save(createNewAccount(savedCustomer));
    }

    /**
     * @param customer - Customer Object
     * @return the new account details
     */
    private Accounts createNewAccount(Customer customer) {
        Accounts newAccount = new Accounts();
        newAccount.setCustomerId(customer.getCustomerId());
        long randomAccNumber = 1000000000L + new Random().nextInt(900000000);

        newAccount.setAccountNumber(randomAccNumber);
        newAccount.setAccountType(AccountsConstants.SAVINGS);
        newAccount.setBranchAddress(AccountsConstants.ADDRESS);
        return newAccount;
    }

    /**
     * @param mobileNumber - Input Mobile Number
     * @return Accounts Details based on a given mobileNumber
     */
    @Override
    public CustomerDto fetchAccount(String mobileNumber) {
        Customer customer = customerRepository.findByMobileNumber(mobileNumber).orElseThrow(
                () -> new ResourceNotFoundException("Customer", "mobileNumber", mobileNumber)
        );
        Accounts accounts = accountsRepository.findByCustomerId(customer.getCustomerId()).orElseThrow(
                () -> new ResourceNotFoundException("Account", "customerId", customer.getCustomerId().toString())
        );
        CustomerDto customerDto = CustomerMapper.mapToCustomerDto(customer, new CustomerDto());
        customerDto.setAccountsDto(AccountsMapper.mapToAccountsDto(accounts, new AccountsDto()));
        return customerDto;
    }

    /**
     * @param customerDto - CustomerDto Object
     * @return boolean indicating if the update of Account details is successful or not
     */
    @Override
    public boolean updateAccount(CustomerDto customerDto) {
        boolean isUpdated = false;
        AccountsDto accountsDto = customerDto.getAccountsDto();
        if(accountsDto !=null ){
            Accounts accounts = accountsRepository.findById(accountsDto.getAccountNumber()).orElseThrow(
                    () -> new ResourceNotFoundException("Account", "AccountNumber", accountsDto.getAccountNumber().toString())
            );
            AccountsMapper.mapToAccounts(accountsDto, accounts);
            accounts = accountsRepository.save(accounts);

            Long customerId = accounts.getCustomerId();
            Customer customer = customerRepository.findById(customerId).orElseThrow(
                    () -> new ResourceNotFoundException("Customer", "CustomerID", customerId.toString())
            );
            CustomerMapper.mapToCustomer(customerDto,customer);
            customerRepository.save(customer);
            isUpdated = true;
        }
        return  isUpdated;
    }

    /**
     * @param mobileNumber - Input Mobile Number
     * @return boolean indicating if the delete of Account details is successful or not
     */
    @Override
    public boolean deleteAccount(String mobileNumber) {
        Customer customer = customerRepository.findByMobileNumber(mobileNumber).orElseThrow(
                () -> new ResourceNotFoundException("Customer", "mobileNumber", mobileNumber)
        );
        accountsRepository.deleteByCustomerId(customer.getCustomerId());
        customerRepository.deleteById(customer.getCustomerId());
        return true;
    }
}


package com.wipro.accounts.exception;
@ResponseStatus(value = HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String resourceName, String fieldName, String fieldValue) {
        super(String.format("%s not found with the given input data %s : '%s'", resourceName, fieldName, fieldValue));
    }

}


@ResponseStatus(value = HttpStatus.BAD_REQUEST)
public class CustomerAlreadyExistsException extends RuntimeException {

    public CustomerAlreadyExistsException(String message) {
        super(message);
    }

}


@ControllerAdvice
public class GlobalExceptionHandler  extends ResponseEntityExceptionHandler {

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {
        Map<String, String> validationErrors = new HashMap<>();
        List<ObjectError> validationErrorList = ex.getBindingResult().getAllErrors();

        validationErrorList.forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String validationMsg = error.getDefaultMessage();
            validationErrors.put(fieldName, validationMsg);
        });
        return new ResponseEntity<>(validationErrors, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDto> handleGlobalException(Exception exception,
                                                                            WebRequest webRequest) {
        ErrorResponseDto errorResponseDTO = new ErrorResponseDto(
                webRequest.getDescription(false),
                HttpStatus.INTERNAL_SERVER_ERROR,
                exception.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(errorResponseDTO, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponseDto> handleResourceNotFoundException(ResourceNotFoundException exception,
                                                                                 WebRequest webRequest) {
        ErrorResponseDto errorResponseDTO = new ErrorResponseDto(
                webRequest.getDescription(false),
                HttpStatus.NOT_FOUND,
                exception.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(errorResponseDTO, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(CustomerAlreadyExistsException.class)
    public ResponseEntity<ErrorResponseDto> handleCustomerAlreadyExistsException(CustomerAlreadyExistsException exception, WebRequest webRequest){
        ErrorResponseDto errorResponseDTO = new ErrorResponseDto(
                webRequest.getDescription(false),
                HttpStatus.BAD_REQUEST,
                exception.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(errorResponseDTO, HttpStatus.BAD_REQUEST);
    }
}



package com.wipro.accounts.constants;
public final class AccountsConstants {

    private AccountsConstants() {
        // restrict instantiation
    }

    public static final String  SAVINGS = "Savings";
    public static final String  ADDRESS = "123 Main Street, New York";
    public static final String  STATUS_201 = "201";
    public static final String  MESSAGE_201 = "Account created successfully";
    public static final String  STATUS_200 = "200";
    public static final String  MESSAGE_200 = "Request processed successfully";
    public static final String  STATUS_417 = "417";
    public static final String  MESSAGE_417_UPDATE= "Update operation failed. Please try again or contact Dev team";
    public static final String  MESSAGE_417_DELETE= "Delete operation failed. Please try again or contact Dev team";
    // public static final String  STATUS_500 = "500";
    // public static final String  MESSAGE_500 = "An error occurred. Please try again or contact Dev team";

}



package com.wipro.accounts.audit;
@Component("auditAwareImpl")
public class AuditAwareImpl implements AuditorAware<String> {
    /**
     * Returns the current auditor of the application.
     *
     * @return the current auditor.
     */
    @Override
    public Optional<String> getCurrentAuditor() {
        return Optional.of("ACCOUNTS_MS");
    }	
}




----- create API inside accounts microservice -------

package com.wipro.accounts.controller;

/**
 * @author Sunil Joseph
 */

@Tag(
        name = "CRUD REST APIs for Accounts in WiproBank",
        description = "CRUD REST APIs in WiproBank to CREATE, UPDATE, FETCH AND DELETE account details"
)
@RestController
@RequestMapping(path="/api", produces = {MediaType.APPLICATION_JSON_VALUE})
@AllArgsConstructor
@Validated
public class AccountsController {

    private IAccountsService iAccountsService;

    @Operation(
            summary = "Create Account REST API",
            description = "REST API to create new Customer &  Account inside EazyBank"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "201",
                    description = "HTTP Status CREATED"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)
                    )
            )
    }
    )
    @PostMapping("/create")
    public ResponseEntity<ResponseDto> createAccount(@Valid @RequestBody CustomerDto customerDto) {
        iAccountsService.createAccount(customerDto);
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(new ResponseDto(AccountsConstants.STATUS_201, AccountsConstants.MESSAGE_201));
    }

    @Operation(
            summary = "Fetch Account Details REST API",
            description = "REST API to fetch Customer &  Account details based on a mobile number"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "HTTP Status OK"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)
                    )
            )
    }
    )
    @GetMapping("/fetch")
    public ResponseEntity<CustomerDto> fetchAccountDetails(@RequestParam
                                                               @Pattern(regexp="(^$|[0-9]{10})",message = "Mobile number must be 10 digits")
                                                               String mobileNumber) {
        CustomerDto customerDto = iAccountsService.fetchAccount(mobileNumber);
        return ResponseEntity.status(HttpStatus.OK).body(customerDto);
    }

    @Operation(
            summary = "Update Account Details REST API",
            description = "REST API to update Customer &  Account details based on a account number"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "HTTP Status OK"
            ),
            @ApiResponse(
                    responseCode = "417",
                    description = "Expectation Failed"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)
                    )
            )
    }
    )
    @PutMapping("/update")
    public ResponseEntity<ResponseDto> updateAccountDetails(@Valid @RequestBody CustomerDto customerDto) {
        boolean isUpdated = iAccountsService.updateAccount(customerDto);
        if(isUpdated) {
            return ResponseEntity
                    .status(HttpStatus.OK)
                    .body(new ResponseDto(AccountsConstants.STATUS_200, AccountsConstants.MESSAGE_200));
        }else{
            return ResponseEntity
                    .status(HttpStatus.EXPECTATION_FAILED)
                    .body(new ResponseDto(AccountsConstants.STATUS_417, AccountsConstants.MESSAGE_417_UPDATE));
        }
    }

    @Operation(
            summary = "Delete Account & Customer Details REST API",
            description = "REST API to delete Customer &  Account details based on a mobile number"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "HTTP Status OK"
            ),
            @ApiResponse(
                    responseCode = "417",
                    description = "Expectation Failed"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)
                    )
            )
    }
    )
    @DeleteMapping("/delete")
    public ResponseEntity<ResponseDto> deleteAccountDetails(@RequestParam
                                                                @Pattern(regexp="(^$|[0-9]{10})",message = "Mobile number must be 10 digits")
                                                                String mobileNumber) {
        boolean isDeleted = iAccountsService.deleteAccount(mobileNumber);
        if(isDeleted) {
            return ResponseEntity
                    .status(HttpStatus.OK)
                    .body(new ResponseDto(AccountsConstants.STATUS_200, AccountsConstants.MESSAGE_200));
        }else{
            return ResponseEntity
                    .status(HttpStatus.EXPECTATION_FAILED)
                    .body(new ResponseDto(AccountsConstants.STATUS_417, AccountsConstants.MESSAGE_417_DELETE));
        }
    }
}


------- AccountsMapper.java ---------
package com.wipro.accounts.mapper;
public class AccountsMapper {

    public static AccountsDto mapToAccountsDto(Accounts accounts, AccountsDto accountsDto) {
        accountsDto.setAccountNumber(accounts.getAccountNumber());
        accountsDto.setAccountType(accounts.getAccountType());
        accountsDto.setBranchAddress(accounts.getBranchAddress());
        return accountsDto;
    }

    public static Accounts mapToAccounts(AccountsDto accountsDto, Accounts accounts) {
        accounts.setAccountNumber(accountsDto.getAccountNumber());
        accounts.setAccountType(accountsDto.getAccountType());
        accounts.setBranchAddress(accountsDto.getBranchAddress());
        return accounts;
    }

}


public class CustomerMapper {

    public static CustomerDto mapToCustomerDto(Customer customer, CustomerDto customerDto) {
        customerDto.setName(customer.getName());
        customerDto.setEmail(customer.getEmail());
        customerDto.setMobileNumber(customer.getMobileNumber());
        return customerDto;
    }

    public static Customer mapToCustomer(CustomerDto customerDto, Customer customer) {
        customer.setName(customerDto.getName());
        customer.setEmail(customerDto.getEmail());
        customer.setMobileNumber(customerDto.getMobileNumber());
        return customer;
    }

}

---> modelmapper.org

create , read, update, delete api inside accounts microservice


@CreatedDate
@CreateadBy @Column(updatable = false)
@LastModifiedDate
@Column(insertable = false)

@EntityListeners(AuditingEntityListener.class)

in bootstrap class
@EnableJpaAuditing(auditorAwareRef = "auditAwareImpl")

package com.wipro.accounts.audit
@Component("auditAwareImpl")
public class AuditAwareImpl implements AuditorAware<String> {
   /**
     * Returns the current auditor of the application.
     *
     * @return the current auditor.
     */
    @Override
    public Optional<String> getCurrentAuditor() {
        return Optional.of("ACCOUNTS_MS");
    }
}
	

https://martinfowler.com/eaaCatalog/dataTransferObject.html


------- documentations ---------------
openapis.org
springdoc.org   -- geting started

dependency - springdoc-openapi-starter-webmvc-ui   - 2.3.0

/swagger-ui/index.html

-- enhancing documentation of REST APIs using @OpenAPIDefinition

-- bootstrap class

@OpenAPIDefinition(
		info = @Info(
				title = "Accounts microservice REST API Documentation",
				description = "WiproBank Accounts microservice REST API Documentation",
				version = "v1",
				contact = @Contact(
						name = "Sunil Joseph",
						email = "sunil.j@wipro.com",
						url = "https://www.wipro.com"
				),
				license = @License(
						name = "Zetta 2.0",
						url = "https://www.wipro.com"
				)
		),
		externalDocs = @ExternalDocumentation(
				description =  "WiproBank Accounts microservice REST API Documentation",
				url = "https://www.wipro.com/swagger-ui.html"
		)
)

--- dcoumentation using @Tag, @Operation, @ApiResponse

controller class
@Tag(
        name = "CRUD REST APIs for Accounts in WiproBank",
        description = "CRUD REST APIs in WiproBank to CREATE, UPDATE, FETCH AND DELETE account details"
)

on API

@Operation(
            summary = "Create Account REST API",
            description = "REST API to create new Customer &  Account inside EazyBank"
    )

@ApiResponses({
            @ApiResponse(
                    responseCode = "201",
                    description = "HTTP Status CREATED"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "HTTP Status Internal Server Error",
                    content = @Content(
                            schema = @Schema(implementation = ErrorResponseDto.class)
                    )
            )
    }
    )


-- documentaion of REST APIs using @Schema & example data

CustomerDto - class level
@Schema(
        name = "Customer",
        description = "Schema to hold Customer and Account information"
)


field level

@Schema(
            description = "Name of the customer", example = "Sunil Joseph"
    )
    @NotEmpty(message = "Name can not be a null or empty")
    @Size(min = 5, max = 30, message = "The length of the customer name should be between 5 and 30")
    private String name;







package com.wipro.accounts.dto;
@Data
@Schema(
        name = "Accounts",
        description = "Schema to hold Account information"
)
public class AccountsDto {

    @NotEmpty(message = "AccountNumber can not be a null or empty")
    @Pattern(regexp="(^$|[0-9]{10})",message = "AccountNumber must be 10 digits")
    @Schema(
            description = "Account Number of WiproBank account", example = "3454433243"
    )
    private Long accountNumber;

    @NotEmpty(message = "AccountType can not be a null or empty")
    @Schema(
            description = "Account type of WiproBank account", example = "Savings"
    )
    private String accountType;

    @NotEmpty(message = "BranchAddress can not be a null or empty")
    @Schema(
            description = "WiproBank branch address", example = "123 NewYork"
    )
    private String branchAddress;
}



---------- CustomerDto.java -------
@Data
@Schema(
        name = "Customer",
        description = "Schema to hold Customer and Account information"
)
public class CustomerDto {

    @Schema(
            description = "Name of the customer", example = "Sunil Joseph"
    )
    @NotEmpty(message = "Name can not be a null or empty")
    @Size(min = 5, max = 30, message = "The length of the customer name should be between 5 and 30")
    private String name;

    @Schema(
            description = "Email address of the customer", example = "sunil.j@wipro.com"
    )
    @NotEmpty(message = "Email address can not be a null or empty")
    @Email(message = "Email address should be a valid value")
    private String email;

    @Schema(
            description = "Mobile Number of the customer", example = "9345432123"
    )
    @Pattern(regexp = "(^$|[0-9]{10})", message = "Mobile number must be 10 digits")
    private String mobileNumber;

    @Schema(
            description = "Account details of the Customer"
    )
    private AccountsDto accountsDto;
}


----- ResponseDto.java ----------
@Schema(
        name = "Response",
        description = "Schema to hold successful response information"
)
@Data @AllArgsConstructor
public class ResponseDto {

    @Schema(
            description = "Status code in the response"
    )
    private String statusCode;

    @Schema(
            description = "Status message in the response"
    )
    private String statusMsg;
    
}


---------- ErrorResponseDto.java -------------
@Data @AllArgsConstructor
@Schema(
        name = "ErrorResponse",
        description = "Schema to hold error response information"
)
public class ErrorResponseDto {

    @Schema(
            description = "API path invoked by client"
    )
    private  String apiPath;

    @Schema(
            description = "Error code representing the error happened"
    )
    private HttpStatus errorCode;

    @Schema(
            description = "Error message representing the error happened"
    )
    private  String errorMessage;

    @Schema(
            description = "Time representing when the error happened"
    )
    private LocalDateTime errorTime;

}


