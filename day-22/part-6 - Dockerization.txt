Generate Docker Images - 3 approaches
1) Dockerfile
2) Buildpacks    mvn goal: spring-boot:build-image
3) Google Jib	

----------------------------------------------------------------------------------------------------
1) create a spring boot project
2) create a WelcomeRestController and have a get mapping for /welcome
3) in pom.xml - provide <finalName>sb-docker.jar</finalName>, <packaging>jar....
4) package the application
    cmd>mvn clean install

5) check 
  to run the application
cmd>java -jar sb-docker.jar 		OR mvn spring-boot:run

6) create a file with the name of "Dockerfile" in project folder

# start with a base image containing Java runtime
FROM openjdk:17-jdk-slim   

# information around who maintains the image
MAINTAINER cognizant.com

# add the application's jar to the image
COPY target/sb-docker.jar sb-docker.jar

# execute the application
ENTRYPOINT ["java", "-jar", "sb-docker.jar"]   
    #whenever someone is trying to generate a container from my docker image - please execute 
         java -jar sb-docker.jar command


in addition
EXPOSE 5000    ----> Informs Docker about the port that the container listens on at runtime


7) create a docker image

cmd> docker build . -t sb-docker:1.0

150478 - docker account user name 
- with this command we are telling to docker server there is a Dockerfile inside this folder (. - current folder) - please use the instructions and generate a docker image with the name specified
1.0 is the version (tag)

8) testing
cmd>docker images       docker image ls       docker image list


cmd> docker inspect image <image_id>   --> -- to know whether the docker image is created successfully based on the instructions in Dockerfile



to run the above image or to create a container

cmd>docker run -d -p 9090:8080 sb-docker:1.0

 -p port mapping
 9090:8080 --- what we are telling to the docker server is -  my "docker container" is going to start in the port 8080 (second)
 where as with the first port we are telling to the docker - please expose the  container outside of the docker network at the port 9090; anyone wants to communicate with this container from outside of the docker network , they have to use the first port number in port mapping


cmd> docker ps 
cmd> docker ps -a    ---> all containers included killed ones


- stop the container
cmd>docker stop <container_id 5chars..>

-- to restart the container
cmd>docker start <stopped_container_id>

---------------------------------------------------------------------------
Pushing and Pulling Docker Image to/from Docker Hub

cmd> docker tag sb-docker:1.0 150478/sb-docker:1.0:1.0

- Docker Hub is a Service provided by Docker for finding and sharing  your container images with your teams or with the general public	
https://hub.docker.com  & login

In Command Prompt:

cmd> docker login
username: 150478
password: 11Sxxxxx2


cmd> docker image ls

cmd>docker push <image_name_with_tag>

cmd>docker pull 150478/zettamine:1.0


-- to create a new tag

cmd>docker tag <image_name> <dockerhub_user_name>/<image_name>:1.0.1

cmd>docker tag 150478/sb-docker:1.0 150478/sb-docker:1.1

cmd>docker push 150478/sb-docker:1.1
11782316
----------------------------------------------------------------------------------------------------

Generate Docker Image of Accounts Microservice with Dockerfile

pom.xml --- <packaging>jar</packaging>
<finalName>accounts</finalName>

In application.properties, add following setting --
 spring.h2.console.settings.web-allow-others=true


cmd>mvn -version
cmd>mvn clean install

---- to run the microservice -----
cmd>mvn spring-boot:run

cmd>java -jar target/accounts.jar

Create a file with name "Dockerfile" in project folder

# start with a base image containing Java runtime
FROM openjdk:17-jdk-slim   

# information around who maintains the image
MAINTAINER cognizant.com

# add the application's jar to the image
COPY target/accounts.jar accounts.jar

# execute the application
ENTRYPOINT ["java", "-jar", "accounts.jar"]

#whenever someone is trying to generate a container from my docker image - please execute java -jar xxx.jar command



cmd>docker version
--- docker is installed correctly

cmd> docker build . -t 150478/accounts:v1

150478 - docker account user name - with this command we are telling to docker server there is a Dockerfile inside this folder - please use the instrucions and generate a docker image with the name specified

cmd> docker images

cmd> docker inspect image <image_id>
-- to know whether the docker image is created successfully based on the instructions in Dockerfile


--- Running Docker Image of accounts microservice with Dockerfile -----

cmd>docker run -p 8080:8080 150478/accounts:v1
 -p port mapping
 8080:8080 --- what we are telling to the docker server is -  my "docker container" is going to start in the port 8080 (second)
 where as with the first port we are telling to the docker - please expose the  container outside of the docker network at the port 8080; anyone wants to communicate with this container from outside of the docker network , they have to use the first port number in port mapping

cmd>docker run -d -p 8080:8080 150478/accounts:v1

cmd> docker ps 
cmd> docker ps -a    ---> all containers included killed ones


- stop the container
cmd>docker start <stopped_container_id>
---------------------------------------------------------------------------------


--- Challenges with Dockerfile approach to generate the Docker Image -----

1) we need to be an expert of docker to write the commands in Dockerfile - as a java developer (not DevOps engineer)- still we need to know the Dockerfile commands like FROM, MAINTAINER, COPY, ENTRYPOINT etc - think of a situation where the Dockerfile is large - lot of learning curve involved for the developer - why should java developer should know about it?

2) we should know the best practices for creating a Docker file - like the size should be as small as possible, caching, compression, security - our docker image should be secure

3) we need to put lot of efforts

---------------------------------------------------------------------------------


--- Generate Docker Image of Loans microservice with Buildpacks ------

What is buildpacks?
 https://buildpacks.io/

 using buildpacks we can transform our application source code into images that can run on any cloud; no need of writing low level instructions in Dockerfile; with a single maven command we can generate a docker image very easily

buildpacks is developed by Heroku - later Pivotal  joined with Hiroku

buildpacks will scan our source code , dependencies and accordingly it is going to generate the docker image 

https://paketo.io/
paketo buildpacks <--- implementation of  buildpacks


<packaging>jar</packaging>
<finalName>loans</finalName>

spring-boot-maven-plugin - inside pom.xml - we can create a docker image and this plugin internally uses paketo buildpacks to make production ready docker image

<plugins>
 <plugin>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-maven-plugin</artifactId>
   <configuration>
     <!-- provide docker image name -->
     <image>
	<name>${project.artifactId}:v1</name>    150478/loans:v1
     </image>
     <excludes>
 	  <exclude>



cmd>mvn clean spring-boot:build-image

downloads paketobuildpacks for the first time

cmd>docker images 
--check the size of Dockerfile and buildpack images

cmd>docker run -d -p 8081:8090 150478/loans:v1

try with postman/ swagger


<image>
 <name>150478/${project.artifactId}:v1</name>
 <createdDate>${maven.build.timestamp}</createdDate>
</image>





----- Generate Docker Image of Cards microservice with Google Jib ---------

github.com/GoogleContainerTools/Jib

Jib is an open-source tool to containerize your Java applications, includes new features and is production-ready

Jib is going to work only for Java applications, where as buildpacks will work for other languages also

Jib organizes your application into distinct layers; dependencies, resources, and classes; and utilizes Docker image layer caching to keep builds fast by only rebuilding changes. Jib's layer organization and small base image keeps overall image size small which improves performance and portability.

Quick Start > Maven  -- Setup

<packaging>jar</packaging>
copy <plugin>

<build>
 <plugins>
  <plugin>
        <groupId>com.google.cloud.tools</groupId>
        <artifactId>jib-maven-plugin</artifactId>
        <version>3.4.5</version>
        <configuration>
          <to>
            <image>${project.artifactId}:latest</image>
          </to>
        </configuration>
  </plugin>
 </plugins>
</build>


build your image
cmd> mvn compile jib:build

Build to Docker daemon
cmd>mvn compile jib:dockerBuild				cmd>docker logout

Subsequent builds are much faster than the initial build (buildpacks)

CREATED date may be 43 years something (old date)- its not a bug -  they make a start date some where 1983
cmd>docker images   --- check the sizes

cmd>docker run -d -p 9000:9000 150478/cards:v1

Advantage of Google Jib - we can create docker image even if docker is not installed
Jib can also build your image directly to a Docker daemon. This uses the docker command line tool and requires that you have docker available on your PATH.



---- Compare Dockerfile , Buildpacks, Jib approaches ----------

https://buildpacks.io/features/			---> Comparison


----- Pushing Docker Images from our local to remote Docker hub Repository ------

cmd>docker image push docker.io/150478/accounts:v1 
cmd>docker image push docker.io/150478/loans:v1 
cmd>docker image push docker.io/150478/cards:v1 

public view to private view in docker hub - settings - visibility settings - - only
- personal plan can have only one repository as private 

cmd>docker pull 150478/accounts:v1




============= Working with Docker Compose =============

Docker Compose is a component in the Docker ecosystem

Docker compose is used to handle multiple containers

When dealing with the execution of multiple containers utilizing the Docker CLI can be error-prone. Writing commands directly in a terminal window can introduce errors, make the code difficult to comprehend, and pose challenges when attempting to implement version control.

we have 3 microservice images - accounts, cards and loans - to run all these 3 -we need to convert the 3 docker images to containers using "docker run" command. To start the 3 containers we need to issue 3 docker run commands along with image name and port mappings - here comes the use of Docker Compose

https://docs.docker.com/compose/

Docker Compose is a tool for defining and running multi-container applications. It is the key to unlocking a streamlined and efficient development and deployment experience.


Compose works in all environments; production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application:
    - Start, stop, and rebuild services
    - View the status of running services
    - Stream the log output of running services
    - Run a one-off command on a service

Docker Compose will gets installed along with Docker Desktop

-- to install Docker compose if not available
https://docs.docker.com/compose/install/standalone/


cmd>docker compose version

practical - create a file with name "docker-compose.yml" in any of our microservices - in accounts

services:
  accounts:
    image: "cts-accounts:latest"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - ctsbank
  loans:
    image: "cts-loans:latest"
    container_name: loans-ms
    ports:
      - "8090:8090"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - ctsbank
  cards:
    image: "cards:latest"
    container_name: cards-ms
    ports:
      - "9000:9000"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - ctsbank
networks:
  ctsbank:
    driver: "bridge"

-----
accounts, cards, loans   -service name
container_name:  -- if we are not providing then it will be given with a default name
ports - port mapping
 - multiple elements can be  provided like an array , so that we need to provide -

accounts-ms we want provide max 700mb
networks:  - ctsbank  --> 

in this case there is no dependency between these 3 microservices - they are all going to start in isolated network

what if I have a dependency between these microservice ; or in future , each microservice need to talk to each other - in that scenario it is not going to work by default.

To make sure that the intercommunication is working - we need to tag all these microservices into a same network

networks - root element
  ctsbank:
    driver: "bridge"    -- we are telling to docker to create a network with name "ctsbank" with driver - bridge - so that our 3 microservices can communicate each other






---- Running All Microservice container using Docker Compose Command ------------------
accounts>cmd>docker compose up 
  OR
accounts>cmd>docker compose up -d      --- detached mode

cmd>docker ps

try running APIs in postman

cmd>docker compose down

cmd>docker ps
cmd>docker ps -a

cmd> docker compose up -d

cmd>docker compose stop
cmd>docker ps -a

cmd>docker compose start


---- Docker Commands ------------------
page 44


---- Docker extension- Logs Explorer ------------------

Logs Explorer Extension --> View all your container logs in one place so you can debug and troubleshoot faster

Docker Desktop Dashboard -- Add Extensions  - Logs Explorer  - Install
 - open
 - no logs information as there is no containers are up

cmd>docker compose up -d

check in Log Explorer Extension

===============================================================================

Cloud Native Apps & 12/15-Factor Methodology

-----------------------------------------

1) ------------ introduction to cloud-native applications ---------------

What are Cloud-native applications?

The layman definition:

Cloud-native applications are software applications designed specifically to leverage cloud computing principles and take full advantage of cloud-native technologies and services. These applications are built and optimized to run cloud environments, utlizing the scalability, elasticity, and flexibility offered by the cloud.

In simple words - cloud native applications are applications which are built for cloud environment, so that organizations can take complete advantage of cloud provided services and technologies.

Cloud native is the software approach of building, deploying, and managing modern applications in cloud computing environments. 

-- Official Definition by The Cloud Native Computing Foundation (CNCF)

 Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds (cloud environments can be anything like AWS, GCP, our own data center, Azure etc). Containers, Service meshes, microservices,immutable infrastructure, and declarative APIs exemplify this approach.



These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predicatbly with minimal toil (work/effort).



https://www.cncf.io/online-programs/what-is-cloud-native-and-why-does-it-exist/



----- Important Characteristics of cloud-native applications --------

page 47

1) Microservices
2) Containers
3) Scalability & Elasticity
4) DevOps Practices 
5) Resilience & Fault Tolerence
6) Cloud-Native Services





----- Difference between cloud-native Apps & Traditional enterprise Apps --------

Page 48


----- Development Principles of Cloud Native - 12-factors & Beyond --------

Page 49

12factor.net


1) One codebase, one application

2) Dependency Management

3) Design, build, release, run

4) Configuration, credentials & code

5) Logs

6) Disposability

7) Backing Services

8) Environment Parity - Dev/prod parity

9) Administrative Process

10) Port Binding

11) Stateless Processes

12) Concurrency

13) API First

14) Telemetry

15) Authentication & Authorization
